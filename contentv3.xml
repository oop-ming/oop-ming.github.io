<?xml version="1.0" encoding="utf-8"?>

<instance xmlns="http://www.exelearning.org/content/v0.3" reference="1" version="0.3" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemalocation="http://www.exelearning.org/content/v0.3 content.xsd" class="exe.engine.package.Package">
 <dictionary>
  <string role="key" value="_title"></string>
  <unicode value="Objektorientierte Programmierung Skript"></unicode>
  <string role="key" value="idevices"></string>
  <list></list>
  <string role="key" value="_addAccessibilityToolbar"></string>
  <bool value="0"></bool>
  <string role="key" value="_addPagination"></string>
  <bool value="0"></bool>
  <string role="key" value="_addSearchBox"></string>
  <bool value="0"></bool>
  <string role="key" value="_author"></string>
  <unicode value="Jacqueline Rähse"></unicode>
  <string role="key" value="_backgroundImg"></string>
  <unicode value=""></unicode>
  <string role="key" value="_contextMode"></string>
  <unicode value=""></unicode>
  <string role="key" value="_contextPlace"></string>
  <unicode value=""></unicode>
  <string role="key" value="_description"></string>
  <unicode value="Das Skript zur Lehrveranstaltung Objektorientierte Programmierung im Studiengang Medieningenieur an der Fachhochschule Kiel"></unicode>
  <string role="key" value="_docType"></string>
  <unicode value="HTML5"></unicode>
  <string role="key" value="_exportElp"></string>
  <bool value="0"></bool>
  <string role="key" value="_extraHeadContent"></string>
  <unicode value=""></unicode>
  <string role="key" value="_fieldValidationInfo"></string>
  <dictionary>
   <unicode role="key" value="all"></unicode>
   <dictionary>
    <unicode role="key" value="mandatory_fields"></unicode>
    <list>
     <unicode value="pp_title"></unicode>
     <unicode value="pp_lang"></unicode>
     <unicode value="pp_description"></unicode>
     <unicode value="pp_author"></unicode>
     <unicode value="pp_newlicense"></unicode>
    </list>
   </dictionary>
   <unicode role="key" value="procomun"></unicode>
   <dictionary>
    <unicode role="key" value="mandatory_fields"></unicode>
    <list>
     <unicode value="pp_learningResourceType"></unicode>
    </list>
    <unicode role="key" value="values_from_list"></unicode>
    <dictionary>
     <unicode role="key" value="pp_learningResourceType"></unicode>
     <list>
      <unicode value="master class"></unicode>
      <unicode value="closed exercise or problem"></unicode>
      <unicode value="real project"></unicode>
      <unicode value="didactic game"></unicode>
      <unicode value="webquest"></unicode>
      <unicode value="open problem"></unicode>
      <unicode value="simulation"></unicode>
      <unicode value="questionnaire"></unicode>
      <unicode value="conceptual map"></unicode>
     </list>
    </dictionary>
   </dictionary>
  </dictionary>
  <string role="key" value="_intendedEndUserRoleGroup"></string>
  <bool value="0"></bool>
  <string role="key" value="_intendedEndUserRoleTutor"></string>
  <bool value="0"></bool>
  <string role="key" value="_intendedEndUserRoleType"></string>
  <unicode value=""></unicode>
  <string role="key" value="_isChanged"></string>
  <bool value="0"></bool>
  <string role="key" value="_isTemplate"></string>
  <bool value="0"></bool>
  <string role="key" value="_lang"></string>
  <unicode value="de"></unicode>
  <string role="key" value="_learningResourceType"></string>
  <unicode value=""></unicode>
  <string role="key" value="_levelNames"></string>
  <list>
   <unicode value="Thema"></unicode>
   <unicode value="Abschnitt"></unicode>
   <unicode value="Einheit"></unicode>
  </list>
  <string role="key" value="_name"></string>
  <unicode value="OOP_Skript"></unicode>
  <string role="key" value="_nextIdeviceId"></string>
  <int value="20"></int>
  <string role="key" value="_nextNodeId"></string>
  <int value="15"></int>
  <string role="key" value="_nodeIdDict"></string>
  <dictionary>
   <unicode role="key" value="0"></unicode>
   <instance class="exe.engine.node.Node" reference="5">
    <dictionary>
     <string role="key" value="_title"></string>
     <unicode value="Objektorientierte Programmierung"></unicode>
     <string role="key" value="idevices"></string>
     <list></list>
     <string role="key" value="_id"></string>
     <unicode value="0"></unicode>
     <string role="key" value="_package"></string>
     <reference key="1"></reference>
     <string role="key" value="anchor_fields"></string>
     <list></list>
     <string role="key" value="exe.engine.node.Node.persistenceVersion"></string>
     <int value="2"></int>
     <string role="key" value="exportType"></string>
     <string value="website"></string>
     <string role="key" value="last_full_node_path"></string>
     <string value="exe-node:Objektorientierte%20Programmierung"></string>
     <string role="key" value="parent"></string>
     <none></none>
     <string role="key" value="top_anchors_linked_from_fields"></string>
     <list></list>
     <string role="key" value="children"></string>
     <list>
      <instance class="exe.engine.node.Node" reference="4">
       <dictionary>
        <string role="key" value="_title"></string>
        <unicode value="Einführung in die objekorientierte Programmierung"></unicode>
        <string role="key" value="idevices"></string>
        <list>
         <instance class="exe.engine.jsidevice.JsIdevice" reference="2">
          <dictionary>
           <string role="key" value="_title"></string>
           <unicode value=""></unicode>
           <string role="key" value="_attributes"></string>
           <list>
            <tuple>
             <string value="title"></string>
             <list>
              <string value="Title"></string>
              <int value="0"></int>
              <int value="0"></int>
             </list>
            </tuple>
            <tuple>
             <string value="category"></string>
             <list>
              <string value="Category"></string>
              <int value="0"></int>
              <int value="1"></int>
             </list>
            </tuple>
            <tuple>
             <string value="css-class"></string>
             <list>
              <string value="CSS class"></string>
              <int value="0"></int>
              <int value="2"></int>
             </list>
            </tuple>
            <tuple>
             <string value="icon"></string>
             <list>
              <string value="Icon"></string>
              <int value="0"></int>
              <int value="3"></int>
             </list>
            </tuple>
           </list>
           <string role="key" value="_author"></string>
           <string value=""></string>
           <string role="key" value="_iDeviceDir"></string>
           <string value="text"></string>
           <string role="key" value="_purpose"></string>
           <string value=""></string>
           <string role="key" value="_tip"></string>
           <string value=""></string>
           <string role="key" value="_typeName"></string>
           <unicode value="Text"></unicode>
           <string role="key" value="_valid"></string>
           <bool value="1"></bool>
           <string role="key" value="class_"></string>
           <unicode value="text"></unicode>
           <string role="key" value="edit"></string>
           <bool value="0"></bool>
           <string role="key" value="emphasis"></string>
           <int value="0"></int>
           <string role="key" value="exe.engine.jsidevice.JsIdevice.persistenceVersion"></string>
           <int value="1"></int>
           <string role="key" value="fields"></string>
           <list>
            <instance class="exe.engine.field.TextAreaField" reference="3">
             <dictionary>
              <string role="key" value="_id"></string>
              <unicode value="128_2"></unicode>
              <string role="key" value="_idevice"></string>
              <reference key="2"></reference>
              <string role="key" value="_instruc"></string>
              <string value=""></string>
              <string role="key" value="_name"></string>
              <string value=""></string>
              <string role="key" value="anchor_names"></string>
              <list></list>
              <string role="key" value="anchors_linked_from_fields"></string>
              <dictionary></dictionary>
              <string role="key" value="content_w_resourcePaths"></string>
              <unicode content="true" value="&lt;div class=&quot;exe-text&quot;&gt;&lt;h1&gt;Einführung – Objektorientierung im Alltag&lt;/h1&gt;
&lt;p&gt;Stell dir vor, du planst den Bau eines Freizeitparks. Anstatt jedes Detail von Grund auf neu zu planen, greifst du auf bewährte Bauelemente zurück: Fahrgeschäfte, Snackbuden, Infozentren – jeweils mit eigenen Eigenschaften und Funktionen. So ähnlich funktioniert die objektorientierte Programmierung (OOP). Anstatt jeden Programmteil als isolierte Befehlsfolge (wie in der prozeduralen Programmierung) zu schreiben, organisieren wir unseren Code in „Objekte“, die sowohl Daten als auch Verhalten kapseln. Für die Studierenden im Studiengang Medieningenieur, die bereits im ersten Semester mit Processing erste Programmiererfahrungen gemacht haben, bietet diese Denkweise einen natürlichen Übergang: Das, was in Processing oft grafisch und interaktiv umgesetzt wurde, wird nun auf ein flexibleres und strukturierteres Fundament gestellt.&lt;/p&gt;
&lt;p&gt;Darum geht es in diesem Kapitel: Wir erläutern, was OOP ist, warum sie in modernen Softwaresystemen so wichtig ist und wie sie sich von herkömmlichen prozeduralen Ansätzen unterscheidet.&lt;/p&gt;
&lt;h2&gt;Die Notwendigkeit von Objektorientierung&lt;/h2&gt;
&lt;p&gt;In vielen Bereichen – sei es in der Softwareentwicklung, der Elektrotechnik oder in den Medien – stoßen wir auf komplexe Systeme. Eine einzelne, monolithische Funktion, die alle Aufgaben abarbeitet, wird schnell unübersichtlich und schwer wartbar. Ein praktisches Beispiel: Stell dir ein Auto vor. Als Außensicht interessiert dich, wie du das Fahrzeug startest, fährst und stoppst – nicht aber, wie der Motor intern funktioniert. Genau hier kommt die Idee der Kapselung ins Spiel: Du interagierst mit dem Auto über klar definierte Schnittstellen (z. B. Zündschlüssel, Lenkrad), während die komplizierten internen Abläufe verborgen bleiben.&lt;/p&gt;
&lt;p&gt;Objektorientierte Programmierung löst dieses Problem, indem sie Programme in eigenständige Objekte unterteilt, die jeweils eine eigene Aufgabe haben. So können beispielsweise in einem Medienprojekt Charaktere, Soundeffekte und Steuerelemente als separate Objekte modelliert werden, die miteinander interagieren. Diese Struktur bringt Vorteile in der Wiederverwendbarkeit, Wartbarkeit und Erweiterbarkeit des Codes.&lt;/p&gt;
&lt;h2&gt;2. Prozedurale Programmierung vs. Objektorientierung&lt;/h2&gt;
&lt;p&gt;Ein kurzer Rückblick: In der prozeduralen Programmierung wird ein Programm als eine Abfolge von Befehlen konstruiert. Der Ablauf ist oft linear, und Daten sowie Funktionen sind getrennt organisiert. Dies erinnert an das Backen eines Kuchens nach einem festen Rezept: Schritt für Schritt werden Zutaten vorbereitet, gemischt und gebacken.&lt;/p&gt;
&lt;p&gt;Im Gegensatz dazu steht die objektorientierte Programmierung, bei der Daten und die darauf operierenden Funktionen in Klassen zusammengefasst werden. Diese Klassen dienen als Baupläne für Objekte. Ein Objekt ist also eine Instanz einer Klasse – vergleichbar mit einem individuellen Auto, das auf dem allgemeinen Bauplan „Auto“ basiert.&lt;/p&gt;
&lt;p&gt;Ein weiterer Vergleich:&lt;/p&gt;
&lt;p&gt;In prozeduralen Systemen gibt es oft globale Variablen und Funktionsaufrufe, die forsch durch den Code springen.&lt;br /&gt;Bei OOP hingegen ist jedes Objekt für sich verantwortlich, seine eigenen Daten zu verwalten – ähnlich wie jedes Auto, das selbstständig fährt und nur mit anderen Fahrzeugen (über klar definierte Schnittstellen) interagiert.&lt;br /&gt;Dieser klare Strukturierungsansatz erleichtert nicht nur das Verstehen des Codes, sondern macht ihn auch flexibler für Änderungen und Erweiterungen.&lt;/p&gt;
&lt;h2&gt;3. Die Grundprinzipien der Objektorientierung&lt;/h2&gt;
&lt;p&gt;OOP beruht auf vier zentralen Prinzipien, die wir anhand alltagstauglicher Beispiele kennenlernen:&lt;/p&gt;
&lt;h3&gt;Abstraktion&lt;/h3&gt;
&lt;p&gt;Abstraktion bedeutet, die wesentlichen Eigenschaften eines Objekts herauszufiltern und unwichtige Details zu verbergen. Betrachte einen Fahrkartenautomaten: Für den Nutzer zählt, dass er ein Ticket kaufen kann – er muss sich nicht damit befassen, wie die internen Berechnungen zur Preisermittlung funktionieren. Diese Vereinfachung trägt dazu bei, komplexe Systeme verständlich darzustellen und erleichtert die Programmierung, da nur die relevanten Merkmale modelliert werden.&lt;/p&gt;
&lt;h3&gt;Kapselung&lt;/h3&gt;
&lt;p&gt;Die Kapselung (Encapsulation) bewirkt, dass Daten und die dazugehörigen Methoden innerhalb eines Objekts verborgen bleiben. Ein klassisches Beispiel ist ein Bankkonto. Du siehst nur deinen Kontostand und hast über definierte Methoden (Einzahlen, Abheben) Zugriff darauf. Die internen Validierungs- und Sicherheitsmechanismen, die den Kontostand vor unautorisierten Änderungen schützen, bleiben verborgen. Dies stellt sicher, dass Daten korrekt und sicher verwaltet werden.&lt;/p&gt;
&lt;h3&gt;Vererbung&lt;/h3&gt;
&lt;p&gt;Vererbung erlaubt es, aus bestehenden Klassen neue Klassen abzuleiten. Stell dir eine Familie von Tieren vor: Die Klasse &quot;Tier&quot; enthält allgemeine Eigenschaften wie Atmung und Fortpflanzung. Spezifischere Klassen wie &quot;Hund&quot; oder &quot;Vogel&quot; erben diese allgemeinen Merkmale und fügen eigene Eigenschaften hinzu (z. B. Bellen oder Fliegen). Diese Hierarchisierung spart nicht nur Code, sondern ermöglicht auch ein systematisches und nachvollziehbares Design.&lt;/p&gt;
&lt;h3&gt;Polymorphismus&lt;/h3&gt;
&lt;p&gt;Polymorphismus (Mehrgestaltigkeit) ermöglicht es, dass Objekte unterschiedlicher Klassen auf dieselbe Schnittstelle reagieren können. Ein gutes Beispiel ist ein Zoo, in dem alle Tiere über die Methode „geräuschMachen()“ verfügen. Dabei kann ein Hund bellen und ein Vogel zwitschern – beide Methodenaufrufe werden in ihrem jeweiligen Kontext korrekt ausgeführt. Polymorphismus vereinfacht den Code, da er die Behandlung unterschiedlicher Objekte unter einer gemeinsamen Schnittstelle ermöglicht.&lt;/p&gt;
&lt;h2&gt;Verbindung zur bisherigen Programmiererfahrung mit Processing&lt;/h2&gt;
&lt;p&gt;Für die Studierenden, die bereits mit Processing gearbeitet haben, bietet sich an, einen Vergleich zu ziehen:&lt;/p&gt;
&lt;p&gt;In Processing wurden bereits grafische Elemente über Klassen modelliert, wenn auch oft vereinfacht.&lt;br /&gt;Das Prinzip der Wiederverwendung von Code – so wie man in Processing häufig eigene Funktionen erstellt hat – findet in OOP seinen erweiterten Ausdruck.&lt;br /&gt;Während in Processing der Fokus oft auf kurzen, visuellen Programmen lag, eröffnet OOP einen strukturierten Ansatz, der sich besonders für umfangreiche und komplexe Systeme eignet.&lt;br /&gt;Der Umstieg von Processing zu einer vollumfänglichen objektorientierten Programmierung in Java bedeutet somit, dass dieselben Konzepte vertieft und um zusätzliche Prinzipien (wie Vererbung und Polymorphismus) erweitert werden. Dies ermöglicht den Studierenden, ihre bisherigen Kenntnisse gezielt auszubauen und in interdisziplinären Projekten – sei es in Medien, Informatik oder Elektrotechnik – erfolgreich einzusetzen.&lt;/p&gt;
&lt;h2&gt;&lt;br /&gt;Praktische Relevanz und didaktischer Nutzen&lt;/h2&gt;
&lt;p&gt;Die objektorientierte Programmierung ist nicht nur ein theoretisches Konstrukt, sondern hat direkten Praxisbezug. Beispielsweise kann ein Softwareprojekt im Medienbereich eine Vielzahl von Objekten beinhalten – von grafischen Elementen bis hin zu interaktiven Steuerungsmechanismen. Die Fähigkeit, komplexe Systeme in überschaubare, wiederverwendbare Einheiten zu zerlegen, ist zentral für die Entwicklung modularer und wartungsfreundlicher Software.&lt;/p&gt;
&lt;p&gt;Ein weiteres Beispiel: In der Entwicklung von mobilen Anwendungen oder in agilen Entwicklungsprozessen spielt die Wiederverwendbarkeit von Code eine wesentliche Rolle. Durch die konsequente Anwendung der OOP-Prinzipien kann der Code nicht nur leichter getestet, sondern auch schneller erweitert werden – ein deutliches Plus in schnelllebigen Entwicklungsumgebungen.&lt;/p&gt;
&lt;h2&gt;Übungsaufgaben&lt;/h2&gt;
&lt;h3&gt;Aufgabe 1: Alltagsmodellierung&lt;/h3&gt;
&lt;p&gt;Erstelle ein einfaches Konzept für ein Objekt aus deinem Alltag, das sich gut für die objektorientierte Modellierung eignet.&lt;/p&gt;
&lt;p&gt;Überlege, welche Eigenschaften (Attribute) und Funktionen (Methoden) in das Objekt integriert werden können.&lt;br /&gt;Notiere dein Konzept stichpunktartig.&lt;br /&gt;Beispiel: Ein „Smartphone“&lt;br /&gt;  - Attribute: Marke, Modell, Betriebssystem, Akkulaufzeit&lt;br /&gt;  - Methoden: Anrufen(), NachrichtSenden(), AppStarten()&lt;/p&gt;
&lt;h3&gt;Aufgabe 2: Vergleich – Prozedural vs. Objektorientiert&lt;/h3&gt;
&lt;p&gt;Überlege dir ein alltägliches Beispiel (z. B. das Zubereiten eines Kaffees) und beschreibe, wie du diesen Prozess prozedural und dann objektorientiert modellieren würdest.&lt;/p&gt;
&lt;p&gt;Erstelle eine kurze Übersicht, in der du die Vor- und Nachteile beider Ansätze gegenüberstellst.&lt;br /&gt;Skizziere ein einfaches Flussdiagramm oder Pseudocode, der den objektorientierten Ansatz veranschaulicht.&lt;/p&gt;
&lt;h2&gt;Übungsfragen&lt;/h2&gt;
&lt;p&gt;Was versteht man unter Abstraktion in der objektorientierten Programmierung, und warum ist sie wichtig?&lt;br /&gt;Erkläre den Unterschied zwischen Kapselung und Vererbung anhand eines praktischen Beispiels aus dem Alltag.&lt;br /&gt;Wie unterscheidet sich die prozedurale Programmierung von der objektorientierten Herangehensweise?&lt;br /&gt;Nenne ein Beispiel, bei dem der Einsatz von Polymorphismus in einer Softwareanwendung besonders vorteilhaft ist.&lt;/p&gt;
&lt;h1&gt;Zusammenfassung&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Objektorientierte Programmierung organisiert den Code in eigenständige Objekte, die Daten und Verhalten bündeln.&lt;/li&gt;
&lt;li&gt;Die vier zentralen Prinzipien sind Abstraktion, Kapselung, Vererbung und Polymorphismus.&lt;/li&gt;
&lt;li&gt;Im Vergleich zur prozeduralen Programmierung bietet OOP eine bessere Strukturierung und Wiederverwendbarkeit von Code.&lt;/li&gt;
&lt;li&gt;Für Studierende des Medieningenieurwesens ist der Übergang von Processing zu Java ein logischer Schritt, um komplexe Systeme modular und übersichtlich zu gestalten.&lt;/li&gt;
&lt;li&gt;Praktische Beispiele aus dem Alltag (z. B. Auto, Bankkonto, Tiere) helfen, die Konzepte anschaulich zu verstehen.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Abschluss&lt;/h1&gt;
&lt;p&gt;Dieses Kapitel hat dir einen umfassenden Überblick über die Grundlagen der objektorientierten Programmierung gegeben. Mit Hilfe alltäglicher Beispiele und einem direkten Vergleich zur prozeduralen Vorgehensweise konntest du die Relevanz und den Mehrwert der OOP erkennen. Die vorgestellten Konzepte bilden das Fundament für die weiteren Kapitel, in denen du tiefer in die einzelnen Details – wie Klassen, Objekte, Vererbung, Polymorphismus und darüber hinaus – eintauchen wirst. Nutze die Übungsaufgaben und -fragen, um dein Verständnis zu überprüfen und erste eigene Modelle zu entwerfen.&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;/div&gt;"></unicode>
              <string role="key" value="exe.engine.field.Field.persistenceVersion"></string>
              <int value="4"></int>
              <string role="key" value="exe.engine.field.FieldWithResources.persistenceVersion"></string>
              <int value="2"></int>
              <string role="key" value="exe.engine.field.TextAreaField.persistenceVersion"></string>
              <int value="3"></int>
              <string role="key" value="htmlTag"></string>
              <string value="div"></string>
              <string role="key" value="images"></string>
              <instance class="exe.engine.galleryidevice.GalleryImages">
               <dictionary>
                <string role="key" value=".listitems"></string>
                <list></list>
                <string role="key" value="idevice"></string>
                <reference key="3"></reference>
               </dictionary>
              </instance>
              <string role="key" value="intlinks_to_anchors"></string>
              <dictionary></dictionary>
              <string role="key" value="nextImageId"></string>
              <int value="0"></int>
              <string role="key" value="parentNode"></string>
              <reference key="4"></reference>
             </dictionary>
            </instance>
           </list>
           <string role="key" value="icon"></string>
           <unicode value=""></unicode>
           <string role="key" value="id"></string>
           <unicode value="13"></unicode>
           <string role="key" value="ideviceCategory"></string>
           <unicode value="Text and Tasks"></unicode>
           <string role="key" value="lastIdevice"></string>
           <bool value="0"></bool>
           <string role="key" value="nextFieldId"></string>
           <int value="3"></int>
           <string role="key" value="originalicon"></string>
           <string value=""></string>
           <string role="key" value="parentNode"></string>
           <reference key="4"></reference>
           <string role="key" value="systemResources"></string>
           <list></list>
           <string role="key" value="undo"></string>
           <bool value="1"></bool>
           <string role="key" value="userResources"></string>
           <list></list>
           <string role="key" value="version"></string>
           <int value="0"></int>
          </dictionary>
         </instance>
        </list>
        <string role="key" value="_id"></string>
        <unicode value="1"></unicode>
        <string role="key" value="_package"></string>
        <reference key="1"></reference>
        <string role="key" value="anchor_fields"></string>
        <list></list>
        <string role="key" value="exe.engine.node.Node.persistenceVersion"></string>
        <int value="2"></int>
        <string role="key" value="exportType"></string>
        <string value="website"></string>
        <string role="key" value="last_full_node_path"></string>
        <string value="exe-node:Objektorientierte%20Programmierung:Einf%C3%BChrung%20in%20die%20objekorientierte%20Programmierung"></string>
        <string role="key" value="parent"></string>
        <reference key="5"></reference>
        <string role="key" value="top_anchors_linked_from_fields"></string>
        <list></list>
        <string role="key" value="children"></string>
        <list></list>
       </dictionary>
      </instance>
      <instance class="exe.engine.node.Node" reference="8">
       <dictionary>
        <string role="key" value="_title"></string>
        <unicode value="Grundlagen der Java-Programmierung"></unicode>
        <string role="key" value="idevices"></string>
        <list>
         <instance class="exe.engine.jsidevice.JsIdevice" reference="6">
          <dictionary>
           <string role="key" value="_title"></string>
           <unicode value=""></unicode>
           <string role="key" value="_attributes"></string>
           <list>
            <tuple>
             <string value="title"></string>
             <list>
              <string value="Title"></string>
              <int value="0"></int>
              <int value="0"></int>
             </list>
            </tuple>
            <tuple>
             <string value="category"></string>
             <list>
              <string value="Category"></string>
              <int value="0"></int>
              <int value="1"></int>
             </list>
            </tuple>
            <tuple>
             <string value="css-class"></string>
             <list>
              <string value="CSS class"></string>
              <int value="0"></int>
              <int value="2"></int>
             </list>
            </tuple>
            <tuple>
             <string value="icon"></string>
             <list>
              <string value="Icon"></string>
              <int value="0"></int>
              <int value="3"></int>
             </list>
            </tuple>
           </list>
           <string role="key" value="_author"></string>
           <string value=""></string>
           <string role="key" value="_iDeviceDir"></string>
           <string value="text"></string>
           <string role="key" value="_purpose"></string>
           <string value=""></string>
           <string role="key" value="_tip"></string>
           <string value=""></string>
           <string role="key" value="_typeName"></string>
           <unicode value="Text"></unicode>
           <string role="key" value="_valid"></string>
           <bool value="1"></bool>
           <string role="key" value="class_"></string>
           <unicode value="text"></unicode>
           <string role="key" value="edit"></string>
           <bool value="0"></bool>
           <string role="key" value="emphasis"></string>
           <int value="0"></int>
           <string role="key" value="exe.engine.jsidevice.JsIdevice.persistenceVersion"></string>
           <int value="1"></int>
           <string role="key" value="fields"></string>
           <list>
            <instance class="exe.engine.field.TextAreaField" reference="7">
             <dictionary>
              <string role="key" value="_id"></string>
              <unicode value="129_2"></unicode>
              <string role="key" value="_idevice"></string>
              <reference key="6"></reference>
              <string role="key" value="_instruc"></string>
              <string value=""></string>
              <string role="key" value="_name"></string>
              <string value=""></string>
              <string role="key" value="anchor_names"></string>
              <list></list>
              <string role="key" value="anchors_linked_from_fields"></string>
              <dictionary></dictionary>
              <string role="key" value="content_w_resourcePaths"></string>
              <unicode content="true" value="&lt;div class=&quot;exe-text&quot;&gt;&lt;h1&gt;Einführung – Der Übergang von Processing zu Java&lt;/h1&gt;
&lt;p&gt;Im ersten Semester hast du bereits mit Processing gearbeitet und grundlegende Programmierkonzepte kennengelernt. Processing basiert auf Java, ist jedoch speziell darauf ausgelegt, kreative und grafische Anwendungen einfach umzusetzen. In diesem Kapitel lernst du, wie du von Processing zu „reinem“ Java übergehst und die Grundlagen der Java-Programmierung meisterst.&lt;/p&gt;
&lt;p&gt;Java ist eine der weltweit am häufigsten verwendeten Programmiersprachen. Sie wird in Bereichen wie Webentwicklung, Mobile Apps, Unternehmenssoftware und sogar in eingebetteten Systemen eingesetzt. Der Übergang von Processing zu Java ermöglicht dir nicht nur, komplexere Anwendungen zu entwickeln, sondern auch, deine Programmierkenntnisse auf ein professionelles Niveau zu heben.&lt;/p&gt;
&lt;h2&gt;1. Einrichtung der Java-Entwicklungsumgebung&lt;/h2&gt;
&lt;p&gt;Um mit Java zu arbeiten, benötigst du eine Entwicklungsumgebung (IDE). Die gängigsten Optionen sind IntelliJ IDEA, Eclipse und NetBeans. Für dieses Skript verwenden wir IntelliJ IDEA.&lt;/p&gt;
&lt;p&gt;Schritte zur Einrichtung:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Java Development Kit (JDK) installieren&lt;br /&gt;Lade das JDK von der offiziellen Oracle-Website oder einer OpenJDK-Quelle herunter und installiere es. Das JDK enthält alles, was du brauchst, um Java-Anwendungen zu schreiben und auszuführen.&lt;/li&gt;
&lt;li&gt;IntelliJ IDEA installieren&lt;br /&gt;Lade IntelliJ IDEA (Community Edition) herunter und installiere es. Diese IDE bietet viele hilfreiche Funktionen wie Syntaxhervorhebung, Autovervollständigung und Debugging-Tools.&lt;/li&gt;
&lt;li&gt;Erstes Projekt erstellen
&lt;ul&gt;
&lt;li&gt;Öffne IntelliJ IDEA und erstelle ein neues Projekt.&lt;/li&gt;
&lt;li&gt;Wähle „Java“ als Projekttyp aus und stelle sicher, dass dein JDK korrekt verknüpft ist.&lt;/li&gt;
&lt;li&gt;Erstelle eine neue Klasse mit dem Namen Main.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;2. Erste Schritte: Dein erstes „Hello World“-Programm&lt;/h2&gt;
&lt;p&gt;Ein klassisches Beispiel für den Einstieg in eine neue Programmiersprache ist das „Hello World“-Programm. Es zeigt dir die grundlegende Struktur eines Java-Programms.&lt;/p&gt;
&lt;div class=&quot;highlighted-code language-java&quot;&gt;
&lt;div&gt;
&lt;pre&gt;&lt;code&gt;public class Main {
   public static void main(String[] args) {
      System.out.println(&quot;Hello World!&quot;);
   }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Erklärung:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;public class Main: Jede Datei in Java enthält mindestens eine Klasse. Hier heißt die Klasse Main.&lt;/li&gt;
&lt;li&gt;public static void main(String[] args): Dies ist die Hauptmethode, die beim Start des Programms ausgeführt wird.&lt;/li&gt;
&lt;li&gt;System.out.println(&quot;Hello World!&quot;);: Gibt den Text „Hello World!“ in der Konsole aus.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Vergleich zu Processing:&lt;/strong&gt;&lt;br /&gt;In Processing würdest du einfach println(&quot;Hello World!&quot;); schreiben. In Java ist die Struktur strenger: Du musst Klassen und Methoden definieren.&lt;/p&gt;
&lt;h2&gt;3. Grundlegende Syntax und Datentypen&lt;/h2&gt;
&lt;h3&gt;Syntax&lt;/h3&gt;
&lt;p&gt;Die Syntax von Java ähnelt anderen C-basierten Sprachen (z. B. C++). Hier einige wichtige Punkte:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Semikolons (;) beenden Anweisungen.&lt;/li&gt;
&lt;li&gt;Blöcke werden durch geschweifte Klammern {} definiert.&lt;/li&gt;
&lt;li&gt;Kommentare:
&lt;ul&gt;
&lt;li&gt;Einzeilig: &lt;code&gt;// Kommentar&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Mehrzeilig:&lt;br /&gt;
&lt;div class=&quot;highlighted-code language-java&quot;&gt;
&lt;div&gt;
&lt;pre&gt;&lt;code&gt;/* &lt;br /&gt;Mehrzeiliger Kommentar &lt;br /&gt;*/&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Datentypen&lt;/h3&gt;
&lt;p&gt;Java unterscheidet zwischen primitiven Datentypen und Referenzdatentypen.&lt;/p&gt;
&lt;table style=&quot;width: 100%;&quot; border=&quot;1&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;width: 33.3333%;&quot;&gt;Primitiver Typ&lt;/td&gt;
&lt;td style=&quot;width: 33.3333%;&quot;&gt;Beschreibung&lt;/td&gt;
&lt;td style=&quot;width: 33.3333%;&quot;&gt;Beispiel&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;width: 33.3333%;&quot;&gt;int&lt;/td&gt;
&lt;td style=&quot;width: 33.3333%;&quot;&gt;Ganze Zahlen&lt;/td&gt;
&lt;td style=&quot;width: 33.3333%;&quot;&gt;int x = 10;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;width: 33.3333%;&quot;&gt;double&lt;/td&gt;
&lt;td style=&quot;width: 33.3333%;&quot;&gt;Gleitkommazahlen&lt;/td&gt;
&lt;td style=&quot;width: 33.3333%;&quot;&gt;double y = 5.5;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;width: 33.3333%;&quot;&gt;char&lt;/td&gt;
&lt;td style=&quot;width: 33.3333%;&quot;&gt;Einzelne Zeichen&lt;/td&gt;
&lt;td style=&quot;width: 33.3333%;&quot;&gt;char c = 'A';&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;width: 33.3333%;&quot;&gt;boolean&lt;/td&gt;
&lt;td style=&quot;width: 33.3333%;&quot;&gt;Wahrheitswerte&lt;/td&gt;
&lt;td style=&quot;width: 33.3333%;&quot;&gt;boolean b = true;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;TODO: Ausführlicher erklären, mehr Datentypen vorstellen. &lt;br /&gt;&lt;strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Vergleich zu Processing:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;In Processing hast du ähnliche Datentypen verwendet, aber weniger strenge Typisierung erlebt (z. B. automatische Konvertierungen). In Java musst du den Typ explizit angeben.&lt;/p&gt;
&lt;p&gt;TODO: enum ergänzen&lt;/p&gt;
&lt;p&gt;TODO: Typumwandlung ergänzen&lt;/p&gt;
&lt;p&gt;TODO: Abschnitt 4 &quot;Ausgabe und Konsole&quot; ergänzen (inklusive String)&lt;/p&gt;
&lt;h2&gt;5. Kontrollstrukturen&lt;/h2&gt;
&lt;p&gt;Kontrollstrukturen steuern den Ablauf deines Programms.&lt;/p&gt;
&lt;h3&gt;If-Anweisung&lt;/h3&gt;
&lt;div class=&quot;highlighted-code language-java&quot;&gt;
&lt;div&gt;
&lt;pre&gt;&lt;code&gt;int x = 10;
if (x &amp;gt; 5) {
   System.out.println(&quot;x ist größer als 5&quot;);
} else {
   System.out.println(&quot;x ist kleiner oder gleich 5&quot;);
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h3&gt;For-Schleife&lt;/h3&gt;
&lt;div class=&quot;highlighted-code language-java&quot;&gt;
&lt;div&gt;
&lt;pre&gt;&lt;code&gt;for (int i = 0; i &amp;lt; 10; i++) {
   System.out.println(i);
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h3&gt;While-Schleife&lt;/h3&gt;
&lt;div class=&quot;highlighted-code language-java&quot;&gt;
&lt;div&gt;
&lt;pre&gt;&lt;code&gt;int i = 0;
while (i &amp;lt; 10) {
   System.out.println(i);
   i++;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Vergleich zu Processing:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Die Syntax für Kontrollstrukturen bleibt nahezu identisch zwischen Processing und Java.&lt;/p&gt;
&lt;h2&gt;6. Arrays&lt;/h2&gt;
&lt;p&gt;Arrays sind Sammlungen von Elementen desselben Typs.&lt;/p&gt;
&lt;div class=&quot;highlighted-code language-java&quot;&gt;
&lt;div&gt;
&lt;pre&gt;&lt;code&gt;int[] zahlen = {1, 2, 3, 4, 5};
System.out.println(zahlen[0]); // Gibt &quot;1&quot; aus&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Vergleich zu Processing:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;In Processing hast du Arrays ähnlich verwendet, aber in Java musst du den Typ explizit angeben.&lt;/p&gt;
&lt;p&gt;TODO: Abschnitt 7 &quot;Methoden&quot; ergänzen (inklusive Überladung und Scope)&lt;/p&gt;
&lt;p&gt;TODO: Abschnitt 8 &quot;Math&quot; ergänzen&lt;/p&gt;
&lt;h1&gt;Übungsaufgaben&lt;/h1&gt;
&lt;h2&gt;Aufgaben&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Schreibe ein Programm, das zwei Zahlen einliest und ihre Summe berechnet.&lt;/li&gt;
&lt;li&gt;Erstelle ein Array mit den Zahlen von 1 bis 10 und gib alle Zahlen in umgekehrter Reihenfolge aus.&lt;/li&gt;
&lt;li&gt;Schreibe ein Programm, das überprüft, ob eine eingegebene Zahl gerade oder ungerade ist.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;Fragen&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Wofür wird die Methode main() in einem Java-Programm verwendet?&lt;/li&gt;
&lt;li&gt;Nenne drei Unterschiede zwischen Processing und Java.&lt;/li&gt;
&lt;li&gt;Was passiert, wenn du ein Semikolon (;) in einer Anweisung vergisst?&lt;/li&gt;
&lt;li&gt;Wie unterscheidet sich ein Array von einer normalen Variablen?&lt;/li&gt;
&lt;/ol&gt;
&lt;h1&gt;Zusammenfassung&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Java ist eine objektorientierte Programmiersprache mit strengerer Syntax als Processing.&lt;/li&gt;
&lt;li&gt;Ein Programm besteht aus Klassen und Methoden; die Hauptmethode heißt main().&lt;/li&gt;
&lt;li&gt;Kontrollstrukturen wie if, for und while ähneln denen in Processing.&lt;/li&gt;
&lt;li&gt;Arrays sind Sammlungen gleichartiger Elemente und müssen in ihrem Typ definiert werden.&lt;/li&gt;
&lt;li&gt;Das „Hello World“-Programm zeigt die grundlegende Struktur eines Java-Codes.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;TODO: Zusammenfassung um weitere Punkte zu den ergänzten Themen ergänzen&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;&lt;/div&gt;"></unicode>
              <string role="key" value="exe.engine.field.Field.persistenceVersion"></string>
              <int value="4"></int>
              <string role="key" value="exe.engine.field.FieldWithResources.persistenceVersion"></string>
              <int value="2"></int>
              <string role="key" value="exe.engine.field.TextAreaField.persistenceVersion"></string>
              <int value="3"></int>
              <string role="key" value="htmlTag"></string>
              <string value="div"></string>
              <string role="key" value="images"></string>
              <instance class="exe.engine.galleryidevice.GalleryImages">
               <dictionary>
                <string role="key" value=".listitems"></string>
                <list></list>
                <string role="key" value="idevice"></string>
                <reference key="7"></reference>
               </dictionary>
              </instance>
              <string role="key" value="intlinks_to_anchors"></string>
              <dictionary></dictionary>
              <string role="key" value="nextImageId"></string>
              <int value="0"></int>
              <string role="key" value="parentNode"></string>
              <reference key="8"></reference>
             </dictionary>
            </instance>
           </list>
           <string role="key" value="icon"></string>
           <unicode value=""></unicode>
           <string role="key" value="id"></string>
           <unicode value="14"></unicode>
           <string role="key" value="ideviceCategory"></string>
           <unicode value="Text and Tasks"></unicode>
           <string role="key" value="lastIdevice"></string>
           <bool value="0"></bool>
           <string role="key" value="nextFieldId"></string>
           <int value="3"></int>
           <string role="key" value="originalicon"></string>
           <string value=""></string>
           <string role="key" value="parentNode"></string>
           <reference key="8"></reference>
           <string role="key" value="systemResources"></string>
           <list></list>
           <string role="key" value="undo"></string>
           <bool value="1"></bool>
           <string role="key" value="userResources"></string>
           <list></list>
           <string role="key" value="version"></string>
           <int value="0"></int>
          </dictionary>
         </instance>
        </list>
        <string role="key" value="_id"></string>
        <unicode value="2"></unicode>
        <string role="key" value="_package"></string>
        <reference key="1"></reference>
        <string role="key" value="anchor_fields"></string>
        <list></list>
        <string role="key" value="exe.engine.node.Node.persistenceVersion"></string>
        <int value="2"></int>
        <string role="key" value="exportType"></string>
        <string value="website"></string>
        <string role="key" value="last_full_node_path"></string>
        <string value="exe-node:Objektorientierte%20Programmierung:Grundlagen%20der%20Java-Programmierung"></string>
        <string role="key" value="parent"></string>
        <reference key="5"></reference>
        <string role="key" value="top_anchors_linked_from_fields"></string>
        <list></list>
        <string role="key" value="children"></string>
        <list>
         <instance class="exe.engine.node.Node" reference="11">
          <dictionary>
           <string role="key" value="_title"></string>
           <unicode value="Ausnahmebehandlung"></unicode>
           <string role="key" value="idevices"></string>
           <list>
            <instance class="exe.engine.jsidevice.JsIdevice" reference="9">
             <dictionary>
              <string role="key" value="_title"></string>
              <unicode value=""></unicode>
              <string role="key" value="_attributes"></string>
              <list>
               <tuple>
                <string value="title"></string>
                <list>
                 <string value="Title"></string>
                 <int value="0"></int>
                 <int value="0"></int>
                </list>
               </tuple>
               <tuple>
                <string value="category"></string>
                <list>
                 <string value="Category"></string>
                 <int value="0"></int>
                 <int value="1"></int>
                </list>
               </tuple>
               <tuple>
                <string value="css-class"></string>
                <list>
                 <string value="CSS class"></string>
                 <int value="0"></int>
                 <int value="2"></int>
                </list>
               </tuple>
               <tuple>
                <string value="icon"></string>
                <list>
                 <string value="Icon"></string>
                 <int value="0"></int>
                 <int value="3"></int>
                </list>
               </tuple>
              </list>
              <string role="key" value="_author"></string>
              <string value=""></string>
              <string role="key" value="_iDeviceDir"></string>
              <string value="text"></string>
              <string role="key" value="_purpose"></string>
              <string value=""></string>
              <string role="key" value="_tip"></string>
              <string value=""></string>
              <string role="key" value="_typeName"></string>
              <unicode value="Text"></unicode>
              <string role="key" value="_valid"></string>
              <bool value="1"></bool>
              <string role="key" value="class_"></string>
              <unicode value="text"></unicode>
              <string role="key" value="edit"></string>
              <bool value="0"></bool>
              <string role="key" value="emphasis"></string>
              <int value="0"></int>
              <string role="key" value="exe.engine.jsidevice.JsIdevice.persistenceVersion"></string>
              <int value="1"></int>
              <string role="key" value="fields"></string>
              <list>
               <instance class="exe.engine.field.TextAreaField" reference="10">
                <dictionary>
                 <string role="key" value="_id"></string>
                 <unicode value="134_2"></unicode>
                 <string role="key" value="_idevice"></string>
                 <reference key="9"></reference>
                 <string role="key" value="_instruc"></string>
                 <string value=""></string>
                 <string role="key" value="_name"></string>
                 <string value=""></string>
                 <string role="key" value="anchor_names"></string>
                 <list></list>
                 <string role="key" value="anchors_linked_from_fields"></string>
                 <dictionary></dictionary>
                 <string role="key" value="content_w_resourcePaths"></string>
                 <unicode content="true" value="&lt;div class=&quot;exe-text&quot;&gt;&lt;p&gt;Die Ausnahmebehandlung ist ein zentraler Bestandteil der Softwareentwicklung, da sie es ermöglicht, unerwartete Fehler – sei es durch falsche Nutzereingaben, fehlende Ressourcen oder defekte Hardware – kontrolliert abzufangen und zu behandeln, ohne dass das gesamte Programm abstürzt2. Im Rahmen des Fachs „Objektorientierte Programmierung“ vertiefen wir hier die Konzepte von try‑catch‑Blöcken, throw, throws, finally und die Definition eigener Exceptions, wobei wir auch darauf eingehen, wie diese Mechanismen im Vergleich zu den Erfahrungen in Processing genutzt werden können27.&lt;/p&gt;
&lt;h2&gt;1. Einführung in die Ausnahmebehandlung&lt;/h2&gt;
&lt;p&gt;Stellen Sie sich vor, Sie möchten eine Kaffeemaschine bedienen: Im besten Fall drückt der Benutzer den richtigen Knopf, und der Kaffee wird zubereitet. Wird jedoch versehentlich ein falscher Knopf gedrückt oder ist eine Komponente defekt, muss das System den Fehler erkennen und darüber informieren, ohne komplett auszuschalten2.&lt;br /&gt;In der Softwareentwicklung funktioniert die Ausnahmebehandlung ähnlich: Statt dass bei einem Fehler das Programm abrupt beendet wird, werden potenziell fehleranfällige Codeabschnitte in einem geschützten Bereich – dem try‑Block – ausgeführt, und auftretende Fehler werden gezielt abgefangen.&lt;/p&gt;
&lt;h2&gt;2. Try‑Catch-Blöcke&lt;/h2&gt;
&lt;p&gt;Der try‑Block fasst alle Codezeilen zusammen, bei denen ein Fehler auftreten könnte.&lt;br /&gt;Kommt ein Fehler (eine „Exception“) vor, wird der reguläre Ausführungsfluss unterbrochen, und die Kontrolle springt zur passenden catch‑Klausel, die den Fehler behandelt27.&lt;br /&gt;Ein einfaches Beispiel ist das Teilen durch Null, das zu einer ArithmeticException führt:&lt;/p&gt;
&lt;div class=&quot;highlighted-code language-java&quot;&gt;
&lt;div&gt;
&lt;pre&gt;&lt;code&gt;try {
   int result = 10 / 0; // Dieser Ausdruck löst eine Exception aus
   System.out.println(&quot;Das Ergebnis ist: &quot; + result);
} catch (ArithmeticException e) {
   System.out.println(&quot;Fehler: Division durch Null ist nicht erlaubt. &quot; + e.getMessage());
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;In diesem Beispiel verhindert der catch‑Block, dass das Programm abstürzt, und gibt stattdessen eine verständliche Fehlermeldung aus.&lt;/p&gt;
&lt;h2&gt;3. Das Schlüsselwort throw und die Deklaration mit throws&lt;/h2&gt;
&lt;p&gt;Manchmal möchte man eine Exception aktiv auslösen – etwa wenn eine Eingabe ungültig ist oder ein bestimmter Zustand nicht erfüllt wird.&lt;br /&gt;Hier kommt das Schlüsselwort throw zum Einsatz; es ermöglicht, eine Exception manuell zu „werfen“.&lt;br /&gt;Zudem kann eine Methode mit dem Schlüsselwort throws deklarieren, welche Exception(s) sie möglicherweise an den aufrufenden Code weitergibt.&lt;/p&gt;
&lt;p&gt;Ein kompaktes Beispiel:&lt;/p&gt;
&lt;div class=&quot;highlighted-code language-java&quot;&gt;
&lt;div&gt;
&lt;pre&gt;&lt;code&gt;public void checkAge(int age) throws IllegalArgumentException {
   if (age &amp;lt; 0) {
      throw new IllegalArgumentException(&quot;Das Alter kann nicht negativ sein!&quot;);
   }
   System.out.println(&quot;Das Alter ist: &quot; + age);
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Beim Aufruf der Methode muss dann entweder eine Exception behandelt oder erneut weitergereicht werden27.&lt;/p&gt;
&lt;h2&gt;4. Der finally-Block&lt;/h2&gt;
&lt;p&gt;Unabhängig davon, ob im try‑Block eine Exception auftritt oder nicht, soll oft abschließender Code ausgeführt werden, beispielsweise zum Freigeben von Ressourcen wie geöffnete Dateien oder Datenbankverbindungen.&lt;br /&gt;Hier kommt der finally‑Block ins Spiel, der immer ausgeführt wird, bevor der Programmfluss fortgesetzt wird27.&lt;/p&gt;
&lt;p&gt;Ein Beispiel:&lt;/p&gt;
&lt;div class=&quot;highlighted-code language-java&quot;&gt;
&lt;div&gt;
&lt;pre&gt;&lt;code&gt;try {
   int result = 10 / 2;
   System.out.println(&quot;Das Ergebnis ist: &quot; + result);
} catch (ArithmeticException e) {
   System.out.println(&quot;Fehler: &quot; + e.getMessage());
} finally {
   System.out.println(&quot;Aufräumarbeiten werden ausgeführt (z. B. Datei schließen).&quot;);
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Dieser Block stellt sicher, dass wichtige Aufräumaufgaben unabhängig vom Ausgang des try‑Blocks durchgeführt werden2.&lt;/p&gt;
&lt;h2&gt;5. Vergleich zwischen Java und Processing&lt;/h2&gt;
&lt;p&gt;In Processing kommt ebenfalls die Verwendung von try‑catch in Frage, wenn auch oft in vereinfachter Form, da viele Fehler bereits in den Grundlagenmodulen behandelt werden.&lt;br /&gt;Java bietet jedoch durch den expliziten Einsatz von throw, throws und finally eine feinere Kontrolle und Dokumentation möglicher Fehlerquellen, was in größeren und komplexeren Anwendungen essenziell ist.&lt;br /&gt;Während in Processing häufig eher intuitive und kompakte Fehlerbehandlungen üblich sind, ermöglicht Java eine strukturiertere und robustere Fehlerverwaltung, die besonders in interdisziplinären Projekten (etwa in der Verbindung von Software mit Hardwarekomponenten) von Vorteil ist.&lt;/p&gt;
&lt;h2&gt;6. Eigene Ausnahmen definieren (Custom Exceptions)&lt;/h2&gt;
&lt;p&gt;Oft ist es sinnvoll, eigene Ausnahmen zu definieren, um spezifische Fehlerfälle klar benennen zu können, wie z. B. fehlerhafte Nutzereingaben oder den Ausfall eines Sensors in eingebetteten Systemen2.&lt;br /&gt;Die Definition einer eigenen Exception erfolgt in Java, indem man die Klasse Exception erweitert:&lt;/p&gt;
&lt;div class=&quot;highlighted-code language-java&quot;&gt;
&lt;div&gt;
&lt;pre&gt;&lt;code&gt; // Definition einer benutzerdefinierten Exception
public class InvalidInputException extends Exception {
   public InvalidInputException(String message) {
      super(message);
   }
}

// Verwendung der benutzerdefinierten Exception in einer Methode
public void validateInput(int input) throws InvalidInputException {
   if (input &amp;lt; 0) {
      throw new InvalidInputException(&quot;Ungültiger Wert: Das Input darf nicht negativ sein.&quot;);
   }
   System.out.println(&quot;Eingabe ist gültig: &quot; + input);
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Durch den gezielten Einsatz eigener Exceptions können Entwickler Fehlerfälle präziser abfangen und dem Benutzer aussagekräftige Rückmeldungen geben – beispielsweise in einer Benutzeroberfläche, die auf defekte Hardware oder nicht erfüllte Systemvoraussetzungen reagiert27.&lt;/p&gt;
&lt;h2&gt;7. Praktische Alltags- und medieningenieurwissenschaftliche Analogien&lt;/h2&gt;
&lt;p&gt;Stellen Sie sich vor, Sie betreiben ein hochmodernes Audiosystem in einem Konzertsaal. Wird eine Komponente (wie ein Verstärker oder ein Lautsprecher) plötzlich nicht erkannt, muss das System den Fehler melden, um eine Katastrophe zu vermeiden – ähnlich wie eine Exception in Java den Programmablauf unterbricht und kontrolliert fortsetzt.&lt;br /&gt;Ein weiteres Beispiel: Wenn ein Benutzer über das Bedienfeld einer Mediaplayer-App eine falsche Eingabe tätigt (z. B. einen ungültigen Dateinamen oder eine falsche Pfadangabe), fängt der try‑Block in Java diesen Fehler ab und der catch‑Block informiert den Benutzer über das Problem, anstatt dass die App abrupt beendet wird.&lt;/p&gt;
&lt;h1&gt;Übungen&lt;/h1&gt;
&lt;h2&gt;Aufgaben&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Aufgabe 1:&lt;br /&gt;Schreibe ein Programm, das den Benutzer zur Eingabe einer Zahl auffordert. Wenn der Benutzer einen ungültigen (z. B. nicht-numerischen) Wert eingibt, soll eine benutzerdefinierte Exception „InvalidInputException“ geworfen und in einem catch‑Block abgefangen werden, sodass eine entsprechende Fehlermeldung ausgegeben wird.&lt;/li&gt;
&lt;li&gt;Aufgabe 2:&lt;br /&gt;Simuliere eine einfache Hardware-Komponente – zum Beispiel einen Sensorsimulator –, der einen Messwert zurückgibt. Falls der Messwert einen bestimmten Schwellenwert unterschreitet oder überschreitet, wirf eine Exception (z. B. SensorMalfunctionException) und fange diese in einem try‑catch‑Block ab, um eine Warnung auszugeben.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Fragen&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Was passiert, wenn im try‑Block eine Exception auftritt, und wie wird diese im catch‑Block verarbeitet?&lt;/li&gt;
&lt;li&gt;Erkläre den Unterschied zwischen throw und throws.&lt;/li&gt;
&lt;li&gt;Welche Aufgabe übernimmt der finally‑Block, und warum ist er nützlich?&lt;/li&gt;
&lt;li&gt;Wie und warum würdest eine eigene Exception definieren?&lt;/li&gt;
&lt;/ol&gt;
&lt;h1&gt;&lt;br /&gt;Zusammenfassung&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;try‑Block: Enthält Code, der potenziell Fehler verursachen kann.&lt;/li&gt;
&lt;li&gt;catch‑Block: Fängt spezifische Exception-Typen ab und behandelt sie, um den Programmfluss aufrechtzuerhalten.&lt;/li&gt;
&lt;li&gt;throw: Ermöglicht das manuelle Auslösen von Exceptions.&lt;/li&gt;
&lt;li&gt;throws: Deklariert in der Methodensignatur, dass eine Methode eine Exception werfen kann.&lt;/li&gt;
&lt;li&gt;finally: Ein Block, der immer ausgeführt wird – ideal für Aufräumarbeiten.&lt;/li&gt;
&lt;li&gt;Custom Exceptions: Erlauben eine präzisere Fehlerbehandlung, indem spezifische Fehlerfälle benannt und behandelt werden.&lt;/li&gt;
&lt;li&gt;Vergleich Processing vs. Java: Während Processing häufig einfachere Ausnahmebehandlungen nutzt, bietet Java durch zusätzliche Keywords wie throw/throws und finally eine detailliertere Kontrolle.&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;"></unicode>
                 <string role="key" value="exe.engine.field.Field.persistenceVersion"></string>
                 <int value="4"></int>
                 <string role="key" value="exe.engine.field.FieldWithResources.persistenceVersion"></string>
                 <int value="2"></int>
                 <string role="key" value="exe.engine.field.TextAreaField.persistenceVersion"></string>
                 <int value="3"></int>
                 <string role="key" value="htmlTag"></string>
                 <string value="div"></string>
                 <string role="key" value="images"></string>
                 <instance class="exe.engine.galleryidevice.GalleryImages">
                  <dictionary>
                   <string role="key" value=".listitems"></string>
                   <list></list>
                   <string role="key" value="idevice"></string>
                   <reference key="10"></reference>
                  </dictionary>
                 </instance>
                 <string role="key" value="intlinks_to_anchors"></string>
                 <dictionary></dictionary>
                 <string role="key" value="nextImageId"></string>
                 <int value="0"></int>
                 <string role="key" value="parentNode"></string>
                 <reference key="11"></reference>
                </dictionary>
               </instance>
              </list>
              <string role="key" value="icon"></string>
              <unicode value=""></unicode>
              <string role="key" value="id"></string>
              <unicode value="7"></unicode>
              <string role="key" value="ideviceCategory"></string>
              <unicode value="Text and Tasks"></unicode>
              <string role="key" value="lastIdevice"></string>
              <bool value="0"></bool>
              <string role="key" value="nextFieldId"></string>
              <int value="3"></int>
              <string role="key" value="originalicon"></string>
              <string value=""></string>
              <string role="key" value="parentNode"></string>
              <reference key="11"></reference>
              <string role="key" value="systemResources"></string>
              <list></list>
              <string role="key" value="undo"></string>
              <bool value="1"></bool>
              <string role="key" value="userResources"></string>
              <list></list>
              <string role="key" value="version"></string>
              <int value="0"></int>
             </dictionary>
            </instance>
           </list>
           <string role="key" value="_id"></string>
           <unicode value="7"></unicode>
           <string role="key" value="_package"></string>
           <reference key="1"></reference>
           <string role="key" value="anchor_fields"></string>
           <list></list>
           <string role="key" value="exe.engine.node.Node.persistenceVersion"></string>
           <int value="2"></int>
           <string role="key" value="exportType"></string>
           <string value="website"></string>
           <string role="key" value="last_full_node_path"></string>
           <string value="exe-node:Objektorientierte%20Programmierung:Grundlagen%20der%20Java-Programmierung:Ausnahmebehandlung"></string>
           <string role="key" value="parent"></string>
           <reference key="8"></reference>
           <string role="key" value="top_anchors_linked_from_fields"></string>
           <list></list>
           <string role="key" value="children"></string>
           <list></list>
          </dictionary>
         </instance>
         <instance class="exe.engine.node.Node" reference="14">
          <dictionary>
           <string role="key" value="_title"></string>
           <unicode value="Collections Framework"></unicode>
           <string role="key" value="idevices"></string>
           <list>
            <instance class="exe.engine.jsidevice.JsIdevice" reference="12">
             <dictionary>
              <string role="key" value="_title"></string>
              <unicode value=""></unicode>
              <string role="key" value="_attributes"></string>
              <list>
               <tuple>
                <string value="title"></string>
                <list>
                 <string value="Title"></string>
                 <int value="0"></int>
                 <int value="0"></int>
                </list>
               </tuple>
               <tuple>
                <string value="category"></string>
                <list>
                 <string value="Category"></string>
                 <int value="0"></int>
                 <int value="1"></int>
                </list>
               </tuple>
               <tuple>
                <string value="css-class"></string>
                <list>
                 <string value="CSS class"></string>
                 <int value="0"></int>
                 <int value="2"></int>
                </list>
               </tuple>
               <tuple>
                <string value="icon"></string>
                <list>
                 <string value="Icon"></string>
                 <int value="0"></int>
                 <int value="3"></int>
                </list>
               </tuple>
              </list>
              <string role="key" value="_author"></string>
              <string value=""></string>
              <string role="key" value="_iDeviceDir"></string>
              <string value="text"></string>
              <string role="key" value="_purpose"></string>
              <string value=""></string>
              <string role="key" value="_tip"></string>
              <string value=""></string>
              <string role="key" value="_typeName"></string>
              <unicode value="Text"></unicode>
              <string role="key" value="_valid"></string>
              <bool value="1"></bool>
              <string role="key" value="class_"></string>
              <unicode value="text"></unicode>
              <string role="key" value="edit"></string>
              <bool value="0"></bool>
              <string role="key" value="emphasis"></string>
              <int value="0"></int>
              <string role="key" value="exe.engine.jsidevice.JsIdevice.persistenceVersion"></string>
              <int value="1"></int>
              <string role="key" value="fields"></string>
              <list>
               <instance class="exe.engine.field.TextAreaField" reference="13">
                <dictionary>
                 <string role="key" value="_id"></string>
                 <unicode value="135_2"></unicode>
                 <string role="key" value="_idevice"></string>
                 <reference key="12"></reference>
                 <string role="key" value="_instruc"></string>
                 <string value=""></string>
                 <string role="key" value="_name"></string>
                 <string value=""></string>
                 <string role="key" value="anchor_names"></string>
                 <list></list>
                 <string role="key" value="anchors_linked_from_fields"></string>
                 <dictionary></dictionary>
                 <string role="key" value="content_w_resourcePaths"></string>
                 <unicode content="true" value="&lt;div class=&quot;exe-text&quot;&gt;&lt;h1&gt;Einführung – Warum Collections?&lt;/h1&gt;
&lt;p&gt;Stell dir vor, du möchtest in einem Mediaplayer eine Playlist verwalten, in der Songs hinzugefügt, gelöscht und sortiert werden können. Oder du entwickelst ein System, das Nutzereingaben speichert und analysiert. Solche Aufgaben erfordern die Verwaltung von Datenstrukturen, die flexibel und effizient sind. Genau hier kommt das Collections Framework von Java ins Spiel. Es bietet eine Vielzahl von Klassen und Interfaces, um Daten zu speichern, zu organisieren und zu verarbeiten.&lt;/p&gt;
&lt;p&gt;In diesem Kapitel lernst du die wichtigsten Collection-Typen kennen: ArrayList, LinkedList, HashMap und Stack. Wir betrachten ihre Eigenschaften, Einsatzmöglichkeiten und wie sie mit Iteratoren, erweiterten For-Schleifen und Streams verarbeitet werden können. Dabei knüpfen wir an den roten Faden der bisherigen Kapitel an, indem wir praktische Beispiele aus der Medien- und Softwareentwicklung verwenden.&lt;/p&gt;
&lt;h2&gt;1. Einführung in das Collections Framework&lt;/h2&gt;
&lt;p&gt;Das Collections Framework ist eine Sammlung von Interfaces und Klassen, die es ermöglichen, Daten effizient zu speichern und zu verwalten. Es bietet Lösungen für häufige Probleme wie:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Dynamische Arrays (z. B. mit ArrayList)&lt;/li&gt;
&lt;li&gt;Schnelle Zuordnung von Schlüsseln zu Werten (z. B. mit HashMap)&lt;/li&gt;
&lt;li&gt;Stapelverarbeitung nach dem Last-In-First-Out-Prinzip (z. B. mit Stack)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Vorteile des Collections Frameworks&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Flexibilität:&lt;/strong&gt; Dynamische Größenanpassung der Datenstrukturen.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Effizienz:&lt;/strong&gt; Optimierte Algorithmen für Suchen, Einfügen und Löschen.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Einheitlichkeit:&lt;/strong&gt; Gemeinsame Schnittstellen für verschiedene Datenstrukturen.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;2. Wichtige Collection-Typen&lt;/h2&gt;
&lt;h3&gt;2.1 ArrayList&lt;/h3&gt;
&lt;p&gt;Die ArrayList ist eine dynamische Liste, die ähnlich wie ein Array funktioniert, aber ihre Größe automatisch anpasst.&lt;/p&gt;
&lt;p&gt;Eigenschaften:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Elemente werden in einer bestimmten Reihenfolge gespeichert.&lt;/li&gt;
&lt;li&gt;Doppelte Werte sind erlaubt.&lt;/li&gt;
&lt;li&gt;Zugriff auf Elemente erfolgt über Indizes.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Beispiel:&lt;/p&gt;
&lt;div class=&quot;highlighted-code language-java&quot;&gt;
&lt;div&gt;
&lt;pre&gt;&lt;code&gt;import java.util.ArrayList;

public class Main {
   public static void main(String[] args) {
      ArrayList&amp;lt;String&amp;gt; playlist = new ArrayList&amp;lt;&amp;gt;();
      playlist.add(&quot;Song A&quot;);
      playlist.add(&quot;Song B&quot;);
      playlist.add(&quot;Song C&quot;);

      // Zugriff auf Elemente
      System.out.println(&quot;Erster Song: &quot; + playlist.get(0));

      // Iteration
      for (String song : playlist) {
         System.out.println(&quot;Song: &quot; + song);
      }
   }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h3&gt;2.2 LinkedList&lt;/h3&gt;
&lt;p&gt;Die LinkedList ist eine Liste, bei der die Elemente als Knoten miteinander verbunden sind.&lt;/p&gt;
&lt;p&gt;Eigenschaften:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Gut geeignet für häufiges Einfügen/Löschen von Elementen.&lt;/li&gt;
&lt;li&gt;Schlechtere Zugriffszeit im Vergleich zur ArrayList.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Beispiel:&lt;/p&gt;
&lt;div class=&quot;highlighted-code language-java&quot;&gt;
&lt;div&gt;
&lt;pre&gt;&lt;code&gt;import java.util.LinkedList;

public class Main {
   public static void main(String[] args) {
      LinkedList&amp;lt;String&amp;gt; queue = new LinkedList&amp;lt;&amp;gt;();
      queue.add(&quot;Task 1&quot;);
      queue.add(&quot;Task 2&quot;);
      queue.addFirst(&quot;Urgent Task&quot;);
   
      // Iteration mit Iterator
      for (String task : queue) {
         System.out.println(&quot;Aufgabe: &quot; + task);
      }
   }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h3&gt;2.3 HashMap&lt;/h3&gt;
&lt;p&gt;Die HashMap ist eine Map-Struktur, die Schlüssel-Wert-Paare speichert.&lt;/p&gt;
&lt;p&gt;Eigenschaften:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Schneller Zugriff auf Werte über Schlüssel.&lt;/li&gt;
&lt;li&gt;Keine garantierte Reihenfolge der Elemente.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Beispiel:&lt;/p&gt;
&lt;div class=&quot;highlighted-code language-java&quot;&gt;
&lt;div&gt;
&lt;pre&gt;&lt;code&gt;import java.util.HashMap;

public class Main {
   public static void main(String[] args) {
      HashMap&amp;lt;Integer, String&amp;gt; userMap = new HashMap&amp;lt;&amp;gt;();
      userMap.put(1, &quot;Alice&quot;);
      userMap.put(2, &quot;Bob&quot;);

      // Zugriff auf Werte
      System.out.println(&quot;Benutzer mit ID 1: &quot; + userMap.get(1));

      // Iteration über Schlüssel-Wert-Paare
      for (var entry : userMap.entrySet()) {
         System.out.println(&quot;ID: &quot; + entry.getKey() + &quot;, Name: &quot; + entry.getValue());
      }
   }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h3&gt;2.4 Stack&lt;/h3&gt;
&lt;p&gt;Der Stack arbeitet nach dem Last-In-First-Out-Prinzip (LIFO). Dies ist besonders nützlich bei Transformationen oder Rückverfolgungen.&lt;/p&gt;
&lt;p&gt;Eigenschaften:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Elemente werden gestapelt (push) und zuletzt hinzugefügte zuerst entfernt (pop).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Beispiel aus Processing:&lt;/p&gt;
&lt;p&gt;In Processing hast du mit pushMatrix() und popMatrix() bereits einen Stack verwendet, um Transformationen des Koordinatensystems zu speichern:&lt;/p&gt;
&lt;div class=&quot;highlighted-code language-java&quot;&gt;
&lt;div&gt;
&lt;pre&gt;&lt;code&gt;Stack&amp;lt;String&amp;gt; stack = new Stack&amp;lt;&amp;gt;();
stack.push(&quot;Transformation 1&quot;);
stack.push(&quot;Transformation 2&quot;);

// Letzte Transformation entfernen
System.out.println(stack.pop()); // Ausgabe: Transformation 2&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h2&gt;3. Iteration über Collections&lt;/h2&gt;
&lt;p&gt;Java bietet verschiedene Möglichkeiten zur Iteration über Collections:&lt;/p&gt;
&lt;h3&gt;3.1 Erweiterte For-Schleife&lt;/h3&gt;
&lt;p&gt;Die erweiterte For-Schleife (for-each) ermöglicht eine einfache Iteration über alle Elemente einer Collection:&lt;/p&gt;
&lt;div class=&quot;highlighted-code language-java&quot;&gt;
&lt;div&gt;
&lt;pre&gt;&lt;code&gt;ArrayList&amp;lt;String&amp;gt; songs = new ArrayList&amp;lt;&amp;gt;();
songs.add(&quot;Song A&quot;);
songs.add(&quot;Song B&quot;);

for (String song : songs) {
   System.out.println(song);
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h3&gt;3.2 Iterator&lt;/h3&gt;
&lt;p&gt;Ein Iterator bietet mehr Kontrolle über die Iteration:&lt;/p&gt;
&lt;div class=&quot;highlighted-code language-java&quot;&gt;
&lt;div&gt;
&lt;pre&gt;&lt;code&gt;import java.util.ArrayList;
import java.util.Iterator;

public class Main {
   public static void main(String[] args) {
      ArrayList&amp;lt;String&amp;gt; songs = new ArrayList&amp;lt;&amp;gt;();
      songs.add(&quot;Song A&quot;);
      songs.add(&quot;Song B&quot;);

      Iterator&amp;lt;String&amp;gt; iterator = songs.iterator();
      while (iterator.hasNext()) {
         System.out.println(iterator.next());
      }
   }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h2&gt;4. Einführung in Streams&lt;/h2&gt;
&lt;p&gt;Streams bieten eine moderne Möglichkeit zur Verarbeitung von Daten in Collections mithilfe von Lambda-Ausdrücken.&lt;/p&gt;
&lt;h3&gt;4.1 Filter&lt;/h3&gt;
&lt;p&gt;Mit filter() kannst du Elemente basierend auf einer Bedingung auswählen:&lt;/p&gt;
&lt;div class=&quot;highlighted-code language-java&quot;&gt;
&lt;div&gt;
&lt;pre&gt;&lt;code&gt;import java.util.ArrayList;
import java.util.stream.Collectors;

public class Main {
   public static void main(String[] args) {
      ArrayList&amp;lt;Integer&amp;gt; numbers = new ArrayList&amp;lt;&amp;gt;();
      numbers.add(10);
      numbers.add(20);
      numbers.add(30);

      // Nur Zahlen größer als 15 filtern
      var filteredNumbers = numbers.stream()
      .filter(n -&amp;gt; n &amp;gt; 15)
      .collect(Collectors.toList());

      System.out.println(filteredNumbers); // Ausgabe: [20, 30]
   }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h3&gt;4.2 Map&lt;/h3&gt;
&lt;p&gt;Mit map() kannst du Elemente transformieren:&lt;/p&gt;
&lt;div class=&quot;highlighted-code language-java&quot;&gt;
&lt;div&gt;
&lt;pre&gt;&lt;code&gt;ArrayList&amp;lt;String&amp;gt; names = new ArrayList&amp;lt;&amp;gt;();
names.add(&quot;Alice&quot;);
names.add(&quot;Bob&quot;);

var upperCaseNames = names.stream()
.map(String::toUpperCase)
.collect(Collectors.toList());

System.out.println(upperCaseNames); // Ausgabe: [ALICE, BOB]&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h1&gt;Übungen&lt;/h1&gt;
&lt;h2&gt;Aufgaben&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Aufgabe 1:&lt;br /&gt;Erstelle ein Programm mit einer ArrayList, in der Songs gespeichert werden können:
&lt;ul&gt;
&lt;li&gt;Füge mindestens fünf Songs hinzu.&lt;/li&gt;
&lt;li&gt;Entferne einen Song aus der Liste.&lt;/li&gt;
&lt;li&gt;Iteriere über die Liste und gib alle Songs aus.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Aufgabe 2:&lt;br /&gt;Simuliere einen Stack für Transformationen in einem Grafikprogramm:
&lt;ul&gt;
&lt;li&gt;Implementiere einen Stack mit Transformationen wie „Translation“ oder „Rotation“.&lt;/li&gt;
&lt;li&gt;Füge Transformationen hinzu und entferne sie schrittweise.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Fragen&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Was sind die Hauptunterschiede zwischen einer ArrayList und einer LinkedList?&lt;/li&gt;
&lt;li&gt;Wie funktioniert das LIFO-Prinzip bei einem Stack?&lt;/li&gt;
&lt;li&gt;Welche Vorteile bietet die Verwendung von Streams gegenüber traditionellen Schleifen?&lt;/li&gt;
&lt;li&gt;Wann würdest du einen Iterator anstelle einer erweiterten For-Schleife verwenden?&lt;/li&gt;
&lt;/ol&gt;
&lt;h1&gt;Zusammenfassung&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Das Java Collections Framework bietet leistungsstarke Klassen wie ArrayList, LinkedList, HashMap und Stack.&lt;/li&gt;
&lt;li&gt;Mit erweiterten For-Schleifen (for-each) und Iteratoren kannst du effizient durch Collections iterieren.&lt;/li&gt;
&lt;li&gt;Streams ermöglichen moderne Datenverarbeitung mit Methoden wie filter() und map().&lt;/li&gt;
&lt;li&gt;Die Wahl der richtigen Collection hängt von den Anforderungen ab – z. B. schneller Zugriff (HashMap) oder dynamische Listen (ArrayList).&lt;br /&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;"></unicode>
                 <string role="key" value="exe.engine.field.Field.persistenceVersion"></string>
                 <int value="4"></int>
                 <string role="key" value="exe.engine.field.FieldWithResources.persistenceVersion"></string>
                 <int value="2"></int>
                 <string role="key" value="exe.engine.field.TextAreaField.persistenceVersion"></string>
                 <int value="3"></int>
                 <string role="key" value="htmlTag"></string>
                 <string value="div"></string>
                 <string role="key" value="images"></string>
                 <instance class="exe.engine.galleryidevice.GalleryImages">
                  <dictionary>
                   <string role="key" value=".listitems"></string>
                   <list></list>
                   <string role="key" value="idevice"></string>
                   <reference key="13"></reference>
                  </dictionary>
                 </instance>
                 <string role="key" value="intlinks_to_anchors"></string>
                 <dictionary></dictionary>
                 <string role="key" value="nextImageId"></string>
                 <int value="0"></int>
                 <string role="key" value="parentNode"></string>
                 <reference key="14"></reference>
                </dictionary>
               </instance>
              </list>
              <string role="key" value="icon"></string>
              <unicode value=""></unicode>
              <string role="key" value="id"></string>
              <unicode value="8"></unicode>
              <string role="key" value="ideviceCategory"></string>
              <unicode value="Text and Tasks"></unicode>
              <string role="key" value="lastIdevice"></string>
              <bool value="0"></bool>
              <string role="key" value="nextFieldId"></string>
              <int value="3"></int>
              <string role="key" value="originalicon"></string>
              <string value=""></string>
              <string role="key" value="parentNode"></string>
              <reference key="14"></reference>
              <string role="key" value="systemResources"></string>
              <list></list>
              <string role="key" value="undo"></string>
              <bool value="1"></bool>
              <string role="key" value="userResources"></string>
              <list></list>
              <string role="key" value="version"></string>
              <int value="0"></int>
             </dictionary>
            </instance>
           </list>
           <string role="key" value="_id"></string>
           <unicode value="8"></unicode>
           <string role="key" value="_package"></string>
           <reference key="1"></reference>
           <string role="key" value="anchor_fields"></string>
           <list></list>
           <string role="key" value="exe.engine.node.Node.persistenceVersion"></string>
           <int value="2"></int>
           <string role="key" value="exportType"></string>
           <string value="website"></string>
           <string role="key" value="last_full_node_path"></string>
           <string value="exe-node:Objektorientierte%20Programmierung:Grundlagen%20der%20Java-Programmierung:Collections%20Framework"></string>
           <string role="key" value="parent"></string>
           <reference key="8"></reference>
           <string role="key" value="top_anchors_linked_from_fields"></string>
           <list></list>
           <string role="key" value="children"></string>
           <list></list>
          </dictionary>
         </instance>
        </list>
       </dictionary>
      </instance>
      <instance class="exe.engine.node.Node" reference="17">
       <dictionary>
        <string role="key" value="_title"></string>
        <unicode value="Klassen und Objekte"></unicode>
        <string role="key" value="idevices"></string>
        <list>
         <instance class="exe.engine.jsidevice.JsIdevice" reference="15">
          <dictionary>
           <string role="key" value="_title"></string>
           <unicode value=""></unicode>
           <string role="key" value="_attributes"></string>
           <list>
            <tuple>
             <string value="title"></string>
             <list>
              <string value="Title"></string>
              <int value="0"></int>
              <int value="0"></int>
             </list>
            </tuple>
            <tuple>
             <string value="category"></string>
             <list>
              <string value="Category"></string>
              <int value="0"></int>
              <int value="1"></int>
             </list>
            </tuple>
            <tuple>
             <string value="css-class"></string>
             <list>
              <string value="CSS class"></string>
              <int value="0"></int>
              <int value="2"></int>
             </list>
            </tuple>
            <tuple>
             <string value="icon"></string>
             <list>
              <string value="Icon"></string>
              <int value="0"></int>
              <int value="3"></int>
             </list>
            </tuple>
           </list>
           <string role="key" value="_author"></string>
           <string value=""></string>
           <string role="key" value="_iDeviceDir"></string>
           <string value="text"></string>
           <string role="key" value="_purpose"></string>
           <string value=""></string>
           <string role="key" value="_tip"></string>
           <string value=""></string>
           <string role="key" value="_typeName"></string>
           <unicode value="Text"></unicode>
           <string role="key" value="_valid"></string>
           <bool value="1"></bool>
           <string role="key" value="class_"></string>
           <unicode value="text"></unicode>
           <string role="key" value="edit"></string>
           <bool value="0"></bool>
           <string role="key" value="emphasis"></string>
           <int value="0"></int>
           <string role="key" value="exe.engine.jsidevice.JsIdevice.persistenceVersion"></string>
           <int value="1"></int>
           <string role="key" value="fields"></string>
           <list>
            <instance class="exe.engine.field.TextAreaField" reference="16">
             <dictionary>
              <string role="key" value="_id"></string>
              <unicode value="130_2"></unicode>
              <string role="key" value="_idevice"></string>
              <reference key="15"></reference>
              <string role="key" value="_instruc"></string>
              <string value=""></string>
              <string role="key" value="_name"></string>
              <string value=""></string>
              <string role="key" value="anchor_names"></string>
              <list></list>
              <string role="key" value="anchors_linked_from_fields"></string>
              <dictionary></dictionary>
              <string role="key" value="content_w_resourcePaths"></string>
              <unicode content="true" value="&lt;div class=&quot;exe-text&quot;&gt;&lt;h1&gt;Einführung – Von Bauplänen zu realen Objekten&lt;/h1&gt;
&lt;p&gt;Stell dir vor, du möchtest ein individuelles Auto bauen. Du hast einen exakten Bauplan, der alle Komponenten des Autos beschreibt – Motor, Karosserie, Räder und Innenausstattung. Dieser Bauplan enthält alle Informationen, die du benötigst, um ein Auto zu produzieren, jedoch ist er selbst noch kein fahrbares Fahrzeug. In der objektorientierten Programmierung (OOP) entspricht dieser Bauplan einer Klasse.&lt;/p&gt;
&lt;p&gt;Einmal erstellt, kannst du anhand dieses Bauplans beliebig viele Autos (Objekte) fertigen – jedes Auto wird zwar nach demselben Konzept gebaut, besitzt jedoch seine eigenen Eigenschaften (z. B. Farbe, Baujahr) und verhält sich in bestimmten Situationen individuell. Genau so verhält es sich in der OOP: Eine Klasse definiert die Struktur und das Verhalten (Methoden), während Objekte konkrete Instanzen dieser Klasse sind. Diese Metapher – vom abstrakten Bauplan zum realen Produkt – soll dir helfen, den grundlegenden Zusammenhang zwischen Klassen und Objekten zu verstehen.&lt;/p&gt;
&lt;p&gt;In diesem Kapitel wirst du lernen:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Was Klassen und Objekte sind&lt;/li&gt;
&lt;li&gt;Wie du Klassen erstellst und Objekte instanziierst&lt;/li&gt;
&lt;li&gt;Welche Rolle Attribute, Methoden und Konstruktoren spielen&lt;/li&gt;
&lt;li&gt;Wie Kapselung (Datenverbergen) zur Sicherung der integrierten Daten beiträgt&lt;/li&gt;
&lt;li&gt;Wie Zugriffsmodifizierer, Getter und Setter den Zugriff steuern und kontrollieren&lt;/li&gt;
&lt;li&gt;Und wie Packages und APIs zur Strukturierung größerer Programme beitragen&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;1. Definition von Klassen&lt;/h2&gt;
&lt;p&gt;In Java beschreibt eine Klasse den Bauplan eines Datentyps. Eine Klasse enthält:&lt;/p&gt;
&lt;p&gt;Attribute (Felder): Diese speichern den Zustand eines Objekts. Bei einem Auto könnten das z. B. die Marke, das Modell und das Baujahr sein.&lt;br /&gt;Methoden: Diese definieren das Verhalten, das Objekte ausführen können. Zum Beispiel könnte eine Methode zum Starten des Motors oder Bremsen gedacht sein.&lt;br /&gt;Die Definition einer Klasse legt also nicht nur fest, wie ein Objekt aussieht, sondern auch, welche Aktionen mit ihm ausgeführt werden können. Hier ein einfaches Beispiel einer Klasse „Auto“:&lt;/p&gt;
&lt;div class=&quot;highlighted-code language-java&quot;&gt;
&lt;div&gt;
&lt;pre&gt;&lt;code&gt;public class Auto {
   // Attribute – der Zustand eines Autos
   private String marke;
   private String modell;
   private int baujahr;

   // Konstruktor: Erzeugt ein neues Auto-Objekt
   public Auto(String marke, String modell, int baujahr) {
      this.marke = marke;
      this.modell = modell;
      this.baujahr = baujahr;
   }

   // Methode: Startet das Auto
   public void starten() {
      System.out.println(&quot;Das Auto startet.&quot;);
   }

   // Getter und Setter für das Attribut 'marke'
   public String getMarke() {
      return marke;
   }

   public void setMarke(String marke) {
      this.marke = marke;
   }

}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;In diesem Beispiel fungiert die Klasse Auto als Bauplan. Sie legt fest, welche Eigenschaften (marke, modell, baujahr) ein Auto besitzt und welche Aktionen (z. B. starten) durchgeführt werden können.&lt;/p&gt;
&lt;h2&gt;&lt;br /&gt;2. Erstellen von Objekten&lt;/h2&gt;
&lt;p&gt;Sobald eine Klasse definiert ist, kannst du Objekte davon instanziieren. Ein Objekt ist eine konkrete Ausprägung der Klasse, vergleichbar mit einem fertigen Auto, das auf Basis des Auto-Bauplans hergestellt wurde.&lt;/p&gt;
&lt;p&gt;So könnte in der Main-Methode eines Programms ein Auto-Objekt erzeugt und verwendet werden:&lt;/p&gt;
&lt;div class=&quot;highlighted-code language-java&quot;&gt;
&lt;div&gt;
&lt;pre&gt;&lt;code&gt;public class Main {
   public static void main(String[] args) {
      // Erzeugen eines Auto-Objekts
      Auto meinAuto = new Auto(&quot;VW&quot;, &quot;Golf&quot;, 2020);
      meinAuto.starten(); // Ruft die Methode 'starten' auf
      System.out.println(&quot;Marke: &quot; + meinAuto.getMarke());
   }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Durch den Konstruktor der Klasse wird das Objekt „meinAuto“ erzeugt und mit individuellen Eigenschaften ausgestattet.&lt;/p&gt;
&lt;h2&gt;&lt;br /&gt;3. Attribute und Methoden&lt;/h2&gt;
&lt;p&gt;Attribute und Methoden bilden das Herzstück einer Klasse:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Attribute (Felder) definieren den Zustand. Sie können verschiedene Datentypen haben (z. B. int, String, boolean).&lt;/li&gt;
&lt;li&gt;Methoden definieren das Verhalten eines Objekts. Sie enthalten Code, der Operationen auf den Attributen oder sonstige Aktionen durchführt.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Ein anschauliches Beispiel:&lt;br /&gt;Stell dir einen „Student“ vor. Er hat Attribute wie Name, Matrikelnummer und Studiengang. Gleichzeitig kann er Aktionen ausführen wie zur Vorlesung gehen oder sich für Prüfungen anmelden. In Java könnte dies folgendermaßen modelliert werden:&lt;/p&gt;
&lt;div class=&quot;highlighted-code language-java&quot;&gt;
&lt;div&gt;
&lt;pre&gt;&lt;code&gt;public class Student {
   private String name;
   private int matrikelnummer;
   private String studiengang;

   // Konstruktor
   public Student(String name, int matrikelnummer, String studiengang) {
      this.name = name;
      this.matrikelnummer = matrikelnummer;
      this.studiengang = studiengang;
   }

   // Eine Methode: Der Student meldet sich an
      public void anmelden() {
      System.out.println(name + &quot; hat sich für den Kurs angemeldet.&quot;);
   }

   // Getter und Setter
   public String getName() {
      return name;
   }

   public void setName(String name) {
      this.name = name;
   }

}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;Diese Trennung von Zustand (Attribute) und Verhalten (Methoden) ist ein zentrales Merkmal der OOP. Durch die klare Strukturierung kann der Code übersichtlicher und modularer gestaltet werden.&lt;/p&gt;
&lt;h2&gt;4. Konstruktoren&lt;/h2&gt;
&lt;p&gt;Ein Konstruktor ist eine spezielle Methode, die beim Erzeugen eines Objekts aufgerufen wird, um es zu initialisieren. Im obigen Beispiel wird durch den Konstruktor der Klasse Auto sicher gestellt, dass beim Erzeugen eines Auto-Objekts die Eigenschaften marke, modell und baujahr gesetzt werden.&lt;/p&gt;
&lt;p&gt;Wichtige Aspekte von Konstruktoren:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Namen: Der Konstruktor hat immer denselben Namen wie die Klasse.&lt;/li&gt;
&lt;li&gt;Keine Rückgabe: Konstruktoren haben keinen Rückgabetyp, auch nicht void.&lt;/li&gt;
&lt;li&gt;Überladung: Es ist möglich, mehrere Konstruktoren mit unterschiedlichen Parameterlisten zu definieren, um Objekte flexibel initialisieren zu können.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Beispiel – Überladene Konstruktoren:&lt;/p&gt;
&lt;div class=&quot;highlighted-code language-java&quot;&gt;
&lt;div&gt;
&lt;pre&gt;&lt;code&gt;public class Auto {
   private String marke;
   private String modell;
   private int baujahr;

   // Konstruktor mit allen Parametern
   public Auto(String marke, String modell, int baujahr) {
      this.marke = marke;
      this.modell = modell;
      this.baujahr = baujahr;
}

   // Konstruktor mit Standardwert für baujahr
   public Auto(String marke, String modell) {
      this(marke, modell, 2025); // Ruft den anderen Konstruktor auf
   }

}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Durch Konstruktorüberladung wird die Initialisierung der Objekte flexibler und einfacher an verschiedene Anforderungen anpassbar.&lt;/p&gt;
&lt;h2&gt;5. Kapselung und das Prinzip der Datenkapselung&lt;/h2&gt;
&lt;p&gt;Ein wesentliches Prinzip der OOP ist die Kapselung (Encapsulation). Mit ihr werden die inneren Details eines Objekts verborgen und nur über definierte Schnittstellen (Methoden) zugänglich gemacht. Dies schützt die Daten vor ungewollten Zugriffen und Manipulationen.&lt;/p&gt;
&lt;p&gt;In der Klasse Auto wird beispielsweise das Attribut marke als private deklariert:&lt;/p&gt;
&lt;div class=&quot;highlighted-code language-java&quot;&gt;
&lt;div&gt;
&lt;pre&gt;&lt;code&gt;private String marke;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Dadurch wird verhindert, dass außerhalb der Klasse direkt darauf zugegriffen wird. Stattdessen werden Getter- und Setter-Methoden angeboten, um kontrolliert Änderungen vorzunehmen:&lt;/p&gt;
&lt;div class=&quot;highlighted-code language-java&quot;&gt;
&lt;div&gt;
&lt;pre&gt;&lt;code&gt;public String getMarke() {
   return marke;
}

public void setMarke(String marke) {
   // Hier können zusätzliche Prüfungen eingebaut werden
   this.marke = marke;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Mit dieser Technik sorgt man dafür, dass die Objektdaten konsistent bleiben und nicht unbeabsichtigt verändert werden.&lt;/p&gt;
&lt;h2&gt;6. Modifikatoren, Getter und Setter&lt;/h2&gt;
&lt;p&gt;Modifikatoren wie private, public und protected steuern den Zugriff auf Klassenmitglieder:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;public: Mitglieder sind von überall zugreifbar.&lt;/li&gt;
&lt;li&gt;private: Mitglieder sind nur innerhalb der gleichen Klasse sichtbar.&lt;/li&gt;
&lt;li&gt;protected: Mitglieder sind innerhalb der gleichen Klasse und deren Subklassen zugänglich.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Getter und Setter sind spezielle Methoden, die den kontrollierten Zugriff auf private Attribute ermöglichen. Sie sind nicht nur nützlich, um Datenlesefehler zu vermeiden, sondern auch um bei Bedarf Logik einzubauen (z. B. Validierungen):&lt;/p&gt;
&lt;div class=&quot;highlighted-code language-java&quot;&gt;
&lt;div&gt;
&lt;pre&gt;&lt;code&gt;public class Student {
   private int matrikelnummer;

   // Getter-Methode
   public int getMatrikelnummer() {
      return matrikelnummer;
   }

   // Setter-Methode
   public void setMatrikelnummer(int matrikelnummer) {
      // Beispiel: Prüfung, dass die Matrikelnummer positiv ist
      if(matrikelnummer &amp;gt; 0) {
         this.matrikelnummer = matrikelnummer;
      } else {
         System.out.println(&quot;Ungültige Matrikelnummer!&quot;);
      }
   }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Mit diesen Techniken können du und deine Mitstudierenden sicherstellen, dass die Datenstrukturen in euren Programmen robust und fehlerresistent bleiben.&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;h1&gt;Übungen&lt;/h1&gt;
&lt;h2&gt;Aufgaben&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Aufgabe 1: Implementierung einer Klasse
&lt;ul&gt;
&lt;li&gt;Erstelle eine Klasse „Auto“ mit den Attributen: marke, modell und baujahr.&lt;/li&gt;
&lt;li&gt;Implementiere einen Konstruktor, der alle Attribute initialisiert.&lt;/li&gt;
&lt;li&gt;Füge eine Methode hinzu, die eine einfache Nachricht ausgibt, z. B. „[Marke] [Modell] startet!“&lt;/li&gt;
&lt;li&gt;Erstelle in einer Main-Methode ein Objekt der Klasse Auto und rufe die Methode auf.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Aufgabe 2: Implementierung von Kapselung
&lt;ul&gt;
&lt;li&gt;Nimm die Klasse „Student“ und deklariere die Attribute (z. B. name, matrikelnummer, studiengang) als private.&lt;/li&gt;
&lt;li&gt;Implementiere jeweils passende Getter und Setter-Methoden.&lt;/li&gt;
&lt;li&gt;Füge Logik in den Setter für die Matrikelnummer ein, sodass nur positive Werte akzeptiert werden.&lt;/li&gt;
&lt;li&gt;Teste deine Implementierung in einer einfachen Main-Methode, indem du versuchst, ungültige Werte zu setzen, und überprüfe, ob deine Validierung wirkt.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Fragen&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Was versteht man unter einer Klasse in der objektorientierten Programmierung?&lt;/li&gt;
&lt;li&gt;Wie unterscheiden sich ein Konstruktor und eine normale Methode?&lt;/li&gt;
&lt;li&gt;Erkläre den Begriff der Kapselung und nenne zwei Vorteile, die sich daraus ergeben.&lt;/li&gt;
&lt;li&gt;Warum werden Attribute in der Regel als private deklariert und über Getter/Setter zugänglich gemacht?&lt;/li&gt;
&lt;/ol&gt;
&lt;h1&gt;Zusammenfassung&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Eine Klasse ist ein Bauplan, der Attribute und Methoden definiert, während ein Objekt eine konkrete Instanz dieser Klasse darstellt.&lt;/li&gt;
&lt;li&gt;Konstruktoren initialisieren Objekte und können überladen werden, um flexible Initialisierungen zu ermöglichen.&lt;/li&gt;
&lt;li&gt;Kapselung verbirgt die internen Details eines Objekts und sorgt für kontrollierten Zugriff über Getter und Setter.&lt;/li&gt;
&lt;li&gt;Zugriffsmodifikatoren (private, public, protected) steuern, wer welche Klassenmitglieder einsehen und verändern darf.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/p&gt;&lt;/div&gt;"></unicode>
              <string role="key" value="exe.engine.field.Field.persistenceVersion"></string>
              <int value="4"></int>
              <string role="key" value="exe.engine.field.FieldWithResources.persistenceVersion"></string>
              <int value="2"></int>
              <string role="key" value="exe.engine.field.TextAreaField.persistenceVersion"></string>
              <int value="3"></int>
              <string role="key" value="htmlTag"></string>
              <string value="div"></string>
              <string role="key" value="images"></string>
              <instance class="exe.engine.galleryidevice.GalleryImages">
               <dictionary>
                <string role="key" value=".listitems"></string>
                <list></list>
                <string role="key" value="idevice"></string>
                <reference key="16"></reference>
               </dictionary>
              </instance>
              <string role="key" value="intlinks_to_anchors"></string>
              <dictionary></dictionary>
              <string role="key" value="nextImageId"></string>
              <int value="0"></int>
              <string role="key" value="parentNode"></string>
              <reference key="17"></reference>
             </dictionary>
            </instance>
           </list>
           <string role="key" value="icon"></string>
           <unicode value=""></unicode>
           <string role="key" value="id"></string>
           <unicode value="15"></unicode>
           <string role="key" value="ideviceCategory"></string>
           <unicode value="Text and Tasks"></unicode>
           <string role="key" value="lastIdevice"></string>
           <bool value="0"></bool>
           <string role="key" value="nextFieldId"></string>
           <int value="3"></int>
           <string role="key" value="originalicon"></string>
           <string value=""></string>
           <string role="key" value="parentNode"></string>
           <reference key="17"></reference>
           <string role="key" value="systemResources"></string>
           <list></list>
           <string role="key" value="undo"></string>
           <bool value="1"></bool>
           <string role="key" value="userResources"></string>
           <list></list>
           <string role="key" value="version"></string>
           <int value="0"></int>
          </dictionary>
         </instance>
        </list>
        <string role="key" value="_id"></string>
        <unicode value="3"></unicode>
        <string role="key" value="_package"></string>
        <reference key="1"></reference>
        <string role="key" value="anchor_fields"></string>
        <list></list>
        <string role="key" value="exe.engine.node.Node.persistenceVersion"></string>
        <int value="2"></int>
        <string role="key" value="exportType"></string>
        <string value="website"></string>
        <string role="key" value="last_full_node_path"></string>
        <string value="exe-node:Objektorientierte%20Programmierung:Klassen%20und%20Objekte"></string>
        <string role="key" value="parent"></string>
        <reference key="5"></reference>
        <string role="key" value="top_anchors_linked_from_fields"></string>
        <list></list>
        <string role="key" value="children"></string>
        <list></list>
       </dictionary>
      </instance>
      <instance class="exe.engine.node.Node" reference="20">
       <dictionary>
        <string role="key" value="_title"></string>
        <unicode value="Vererbung"></unicode>
        <string role="key" value="idevices"></string>
        <list>
         <instance class="exe.engine.jsidevice.JsIdevice" reference="18">
          <dictionary>
           <string role="key" value="_title"></string>
           <unicode value=""></unicode>
           <string role="key" value="_attributes"></string>
           <list>
            <tuple>
             <string value="title"></string>
             <list>
              <string value="Title"></string>
              <int value="0"></int>
              <int value="0"></int>
             </list>
            </tuple>
            <tuple>
             <string value="category"></string>
             <list>
              <string value="Category"></string>
              <int value="0"></int>
              <int value="1"></int>
             </list>
            </tuple>
            <tuple>
             <string value="css-class"></string>
             <list>
              <string value="CSS class"></string>
              <int value="0"></int>
              <int value="2"></int>
             </list>
            </tuple>
            <tuple>
             <string value="icon"></string>
             <list>
              <string value="Icon"></string>
              <int value="0"></int>
              <int value="3"></int>
             </list>
            </tuple>
           </list>
           <string role="key" value="_author"></string>
           <string value=""></string>
           <string role="key" value="_iDeviceDir"></string>
           <string value="text"></string>
           <string role="key" value="_purpose"></string>
           <string value=""></string>
           <string role="key" value="_tip"></string>
           <string value=""></string>
           <string role="key" value="_typeName"></string>
           <unicode value="Text"></unicode>
           <string role="key" value="_valid"></string>
           <bool value="1"></bool>
           <string role="key" value="class_"></string>
           <unicode value="text"></unicode>
           <string role="key" value="edit"></string>
           <bool value="0"></bool>
           <string role="key" value="emphasis"></string>
           <int value="0"></int>
           <string role="key" value="exe.engine.jsidevice.JsIdevice.persistenceVersion"></string>
           <int value="1"></int>
           <string role="key" value="fields"></string>
           <list>
            <instance class="exe.engine.field.TextAreaField" reference="19">
             <dictionary>
              <string role="key" value="_id"></string>
              <unicode value="127_2"></unicode>
              <string role="key" value="_idevice"></string>
              <reference key="18"></reference>
              <string role="key" value="_instruc"></string>
              <string value=""></string>
              <string role="key" value="_name"></string>
              <string value=""></string>
              <string role="key" value="anchor_names"></string>
              <list></list>
              <string role="key" value="anchors_linked_from_fields"></string>
              <dictionary></dictionary>
              <string role="key" value="content_w_resourcePaths"></string>
              <unicode content="true" value="&lt;div class=&quot;exe-text&quot;&gt;&lt;h1&gt;Einführung – Vererbung im Alltag&lt;/h1&gt;
&lt;p&gt;Stellt euch vor, ihr betrachtet die Tierwelt: Alle Tiere besitzen gewisse gemeinsame Merkmale wie Atmung, Fortpflanzung oder Bewegung. Gleichzeitig unterscheiden sich Tiere jedoch in spezifischen Eigenschaften – ein Hund bellt, während eine Katze miaut. Dieses Grundprinzip, dass allgemeine Eigenschaften (zum Beispiel „Tiersein“) an spezifische Gruppen (wie Hund oder Katze) weitergegeben werden, bildet den Kern der Vererbung in der objektorientierten Programmierung (OOP).&lt;br /&gt;In eurem bisherigen Programmierunterricht – unter anderem mit Processing – habt ihr bereits gelernt, wie Code wiederverwendet werden kann. Die Vererbung geht diesen Ansatz noch einen großen Schritt weiter: Sie ermöglicht es, allgemeine Funktionalitäten in einer Oberklasse (Superklasse) zu definieren und diese in spezialisierten Klassen (Subklassen) automatisch zu übernehmen und bei Bedarf anzupassen. Damit wird nicht nur redundanter Code vermieden, sondern auch die Wartbarkeit und Erweiterbarkeit eurer Programme deutlich verbessert.&lt;br /&gt;In diesem Kapitel erfahrt ihr, was Vererbung bedeutet, wie sie in Java syntaktisch umgesetzt wird und welche Vorteile sie in der Softwareentwicklung bietet – immer vor dem Hintergrund eurer interdisziplinären Studienrichtung Medieningenieurwesen.&lt;/p&gt;
&lt;h2&gt;1. Was ist Vererbung?&lt;/h2&gt;
&lt;p&gt;Vererbung beschreibt den Mechanismus, bei dem eine Klasse (die Superklasse) Eigenschaften und Methoden an eine oder mehrere abgeleitete Klassen (Subklassen) weitergibt. Dabei werden gemeinsame Merkmale einmal definiert und müssen nicht in jeder Subklasse erneut implementiert werden.&lt;br /&gt;Beispiel aus dem Alltag:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Die Superklasse „Tier“ könnte allgemeine Eigenschaften wie Name und Alter sowie Methoden wie geraeuschMachen() enthalten.&lt;/li&gt;
&lt;li&gt;Die Subklassen „Hund“, „Katze“ oder „Vogel“ erben diese Eigenschaften automatisch und können zusätzlich ihr eigenes spezifisches Verhalten implementieren – ein Hund bellt, eine Katze miaut, ein Vogel zwitschert.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Dies verdeutlicht das Prinzip: Allgemeines Verhalten und Daten werden zentral definiert, während spezielle Abweichungen individuell überschrieben werden können.&lt;/p&gt;
&lt;h2&gt;2. Vorteile der Vererbung&lt;/h2&gt;
&lt;p&gt;Die Verwendung von Vererbung bringt zahlreiche Vorteile in der objektorientierten Programmierung mit sich:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Wiederverwendbarkeit: Einmal definierte Eigenschaften in der Superklasse werden in allen Subklassen verfügbar, was den Programmieraufwand reduziert.&lt;/li&gt;
&lt;li&gt;Wartbarkeit: Änderungen in der Superklasse wirken sich automatisch auf alle abgeleiteten Klassen aus, sofern die vererbten Methoden genutzt werden.&lt;/li&gt;
&lt;li&gt;Erweiterbarkeit: Neue Klassen können durch Ableiten von bestehenden Klassen schnell erweitert werden, ohne den gesamten Code neu schreiben zu müssen.&lt;/li&gt;
&lt;li&gt;Strukturierung: Komplexe Systeme werden in eine logische Hierarchie unterteilt, was das Verständnis und die Modellierung realer Zusammenhänge erleichtert.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Angesichts des interdisziplinären Charakters des Studiengangs Medieningenieurwesen, in dem Informatik, Elektrotechnik und Medien kombiniert werden, hilft Vererbung dabei, wiederkehrende Logiken zentral zu erfassen und leicht an veränderte Anforderungen anzupassen.&lt;/p&gt;
&lt;h2&gt;&lt;br /&gt;3. Implementierung von Vererbung in Java&lt;/h2&gt;
&lt;p&gt;In Java erfolgt die Vererbung mittels des Schlüsselworts „extends“. Eine Klasse, die eine andere Klasse erweitert, übernimmt damit alle öffentlichen und geschützten (protected) Eigenschaften und Methoden der Superklasse.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Beispiel: Tierhierarchie&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Wir definieren zunächst eine Superklasse Tier:&lt;/p&gt;
&lt;div class=&quot;highlighted-code language-java&quot;&gt;
&lt;div&gt;
&lt;pre&gt;&lt;code&gt;public class Tier {
   // Geschützte Attribute, damit Subklassen darauf zugreifen können
   protected String name;
   protected int alter;

   // Konstruktor der Superklasse
   public Tier(String name, int alter) {
      this.name = name;
      this.alter = alter;
   }

   // Methode, die allgemeines Verhalten beschreibt
   public void geraeuschMachen() {
      System.out.println(&quot;Das Tier macht ein Geräusch.&quot;);
   }

}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;Nun erstellen wir eine Subklasse Hund, die von Tier erbt:&lt;/p&gt;
&lt;div class=&quot;highlighted-code language-java&quot;&gt;
&lt;div&gt;
&lt;pre&gt;&lt;code&gt;public class Hund extends Tier {

   // Konstruktor der Subklasse, ruft den Konstruktor der Superklasse auf
   public Hund(String name, int alter) {
      super(name, alter);
   }

   // Überschreiben der Methode, um spezielles Verhalten zu definieren
   @Override
   public void geraeuschMachen() {
      System.out.println(name + &quot; bellt: Wuff!&quot;);
   }

}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;Erklärung der wichtigen Elemente:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Das Schlüsselwort „extends“ zeigt an, dass Hund von Tier erbt.&lt;/li&gt;
&lt;li&gt;Mit dem Aufruf von super(name, alter) im Konstruktor der Subklasse wird der Konstruktor der Oberklasse ausgeführt, sodass die Attribute korrekt initialisiert werden.&lt;/li&gt;
&lt;li&gt;Die Methode geraeuschMachen() wird in der Subklasse überschrieben (Method Overriding). Dadurch wird das spezifische Verhalten (Bellen) implementiert, während die Grundstruktur aus der Superklasse übernommen wird.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Diese Technik der Vererbung ermöglicht es, zunächst allgemeine Verhaltensweisen zu definieren und sie später in den abgeleiteten Klassen zu spezifizieren.&lt;/p&gt;
&lt;h2&gt;4. Das Schlüsselwort „super“&lt;/h2&gt;
&lt;p&gt;Das Schlüsselwort „super“ spielt in der Vererbung eine zentrale Rolle. Es dient dazu, auf die Mitglieder (Attribute und Methoden) der Superklasse zuzugreifen.&lt;br /&gt;Mögliche Einsatzgebiete:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Aufruf des Konstruktors der Superklasse – wie im obigen Beispiel, um die Initialisierung zu garantieren.&lt;/li&gt;
&lt;li&gt;Zugriff auf Methoden oder Attribute der Superklasse, wenn diese in der Subklasse überschrieben wurden.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Beispiel:&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;highlighted-code language-java&quot;&gt;
&lt;div&gt;
&lt;pre&gt;&lt;code&gt;public class Katze extends Tier {

   public Katze(String name, int alter) {
      super(name, alter);
   }

   @Override
   public void geraeuschMachen() {
      // Aufruf der ursrprünglichen Implementierung aus der Superklasse,
      // falls gewünscht, bevor der spezifische Code ausgeführt wird
      super.geraeuschMachen();
      System.out.println(name + &quot; miaut: Miau!&quot;);
   }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;In diesem Beispiel wird zunächst die Methode geraeuschMachen() der Superklasse aufgerufen und anschließend ein zusätzlicher, spezifischer Teil ausgeführt. Dadurch wird klar, wie Vererbung eine flexible Erweiterung und Anpassung der bestehenden Funktionalitäten ermöglicht.&lt;/p&gt;
&lt;h2&gt;5. Formen von Vererbung und ihre Besonderheiten in Java&lt;/h2&gt;
&lt;p&gt;In der objektorientierten Programmierung gibt es verschiedene Ansätze der Vererbung:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Einfachvererbung&lt;/strong&gt;: Eine Klasse erbt von genau einer Superklasse. Dies ist die in Java vorherrschende Form, da Java – im Gegensatz zu einigen anderen Programmiersprachen – keine Mehrfachvererbung von Klassen zulässt.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Mehrfachvererbung (von Klassen)&lt;/strong&gt;: Bei einigen Sprachen möglich, in Java aber nicht direkt unterstützt. Stattdessen können Schnittstellen (Interfaces) genutzt werden, um ähnliche Funktionalitäten zu realisieren.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Hybridlösungen&lt;/strong&gt;: Mit abstrakten Klassen und Interfaces lassen sich teilweise mehrdimensionale Vererbungseffekte erzielen, ohne die Nachteile und Komplexitäten der Mehrfachvererbung zu riskieren.&lt;br /&gt;Der Verzicht auf Mehrfachvererbung bei Klassen in Java dient der Klarheit: Ein Konflikt, wenn zwei Superklassen unterschiedliche Implementierungen einer Methode liefern, wird so elegant vermieden. Falls dennoch mehrere Verhaltensweisen benötigt werden, kann eine Klasse mehrere Interfaces implementieren.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;6. Praktische Anwendung der Vererbung&lt;/h2&gt;
&lt;p&gt;Um das Konzept zu verdeutlichen, schauen wir uns ein praktisches Szenario an: Ein Medienprojekt, in dem verschiedene grafische Objekte modelliert werden sollen.&lt;br /&gt;Nehmen wir an, ihr entwickelt eine Anwendung, in der verschiedene Formen (Kreise, Rechtecke und Dreiecke) gezeichnet werden sollen. Eine abstrakte Superklasse „Form“ definiert grundlegende Attribute wie Position und Farbe sowie eine Methode draw(), die in den abgeleiteten Klassen jeweils spezifiziert wird.&lt;br /&gt;Dieses Prinzip der Vererbung erlaubt es, alle gemeinsamen Eigenschaften zentral zu verwalten und nur die fachspezifischen Unterschiede in den Subklassen zu implementieren.&lt;br /&gt;Analog zur Tierhierarchie wird hier die Vererbung dazu genutzt, den Code übersichtlich und wiederverwendbar zu gestalten – ein zentraler Aspekt im interdisziplinären Arbeiten, beispielsweise bei der Entwicklung von Animationen oder interaktiven Medienanwendungen.&lt;/p&gt;
&lt;h1&gt;Übungen&lt;/h1&gt;
&lt;h2&gt;Aufgaben&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Aufgabe 1: Tierhierarchie implementieren
&lt;ul&gt;
&lt;li&gt;Erstelle eine Superklasse „Tier“ mit den Attributen name (String) und alter (int) sowie einer Methode geraeuschMachen(), die ein generisches Geräusch ausgibt.&lt;/li&gt;
&lt;li&gt;Implementiere die Subklassen „Hund“ und „Katze“, die jeweils die Methode geraeuschMachen() überschreiben, um spezifische Geräusche (z. B. Bellen und Miauen) auszugeben.&lt;/li&gt;
&lt;li&gt;Teste die Klassen in einer Main-Methode, indem du mehrere Tier-Objekte erzeugst und deren Methoden aufrufst.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Aufgabe 2: Erweiterung mit zusätzlichen Eigenschaften
&lt;ul&gt;
&lt;li&gt;Ergänze die Superklasse „Tier“ um ein Attribut habitat (z. B. &quot;Wald&quot;, &quot;Haus&quot;, &quot;Aquarium&quot;).&lt;/li&gt;
&lt;li&gt;Erstelle eine weitere Subklasse „Vogel“, die zusätzlich die Methode fliegen() implementiert und eventuell ein Attribut fluegelSpannweite besitzt.&lt;/li&gt;
&lt;li&gt;Nutze das Schlüsselwort super, um den Konstruktor der Superklasse aufzurufen und die gemeinsamen Attribute korrekt zu initialisieren.&lt;/li&gt;
&lt;li&gt;Teste euer Programm, indem du Objekte der Klassen Hund, Katze und Vogel erstellst und deren Verhalten demonstrierst.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Fragen&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Was versteht man unter Vererbung in der objektorientierten Programmierung, und welche Vorteile bietet sie?&lt;/li&gt;
&lt;li&gt;Wie wird in Java die Vererbung syntaktisch umgesetzt, und welche Rolle spielt dabei das Schlüsselwort „extends“?&lt;/li&gt;
&lt;li&gt;Erklärt bitte den Zweck des Schlüsselworts „super“ in Konstruktoren und Methoden.&lt;/li&gt;
&lt;li&gt;Warum erlaubt Java keine Mehrfachvererbung von Klassen, und welche Alternative bietet Java zur Implementierung mehrerer Verhaltensweisen?&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;/p&gt;
&lt;h1&gt;Zusammenfassung&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Vererbung ermöglicht es, gemeinsame Eigenschaften und Methoden in einer Superklasse zu definieren und diese in allen abgeleiteten Subklassen wiederzuverwenden.&lt;/li&gt;
&lt;li&gt;In Java wird Vererbung mit dem Schlüsselwort „extends“ umgesetzt.&lt;/li&gt;
&lt;li&gt;Das Schlüsselwort „super“ wird genutzt, um auf Konstruktoren, Methoden und Attribute der Superklasse zuzugreifen.&lt;/li&gt;
&lt;li&gt;Vererbung fördert Wiederverwendbarkeit, Wartbarkeit und Erweiterbarkeit des Codes – wichtige Aspekte in interdisziplinären Projekten im Medieningenieurwesen.&lt;/li&gt;
&lt;li&gt;Java unterstützt standardmäßig nur Einfachvererbung, wobei Mehrfachvererbung durch Interfaces abgefedert wird.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/p&gt;&lt;/div&gt;"></unicode>
              <string role="key" value="exe.engine.field.Field.persistenceVersion"></string>
              <int value="4"></int>
              <string role="key" value="exe.engine.field.FieldWithResources.persistenceVersion"></string>
              <int value="2"></int>
              <string role="key" value="exe.engine.field.TextAreaField.persistenceVersion"></string>
              <int value="3"></int>
              <string role="key" value="htmlTag"></string>
              <string value="div"></string>
              <string role="key" value="images"></string>
              <instance class="exe.engine.galleryidevice.GalleryImages">
               <dictionary>
                <string role="key" value=".listitems"></string>
                <list></list>
                <string role="key" value="idevice"></string>
                <reference key="19"></reference>
               </dictionary>
              </instance>
              <string role="key" value="intlinks_to_anchors"></string>
              <dictionary></dictionary>
              <string role="key" value="nextImageId"></string>
              <int value="0"></int>
              <string role="key" value="parentNode"></string>
              <reference key="20"></reference>
             </dictionary>
            </instance>
           </list>
           <string role="key" value="icon"></string>
           <unicode value=""></unicode>
           <string role="key" value="id"></string>
           <unicode value="16"></unicode>
           <string role="key" value="ideviceCategory"></string>
           <unicode value="Text and Tasks"></unicode>
           <string role="key" value="lastIdevice"></string>
           <bool value="0"></bool>
           <string role="key" value="nextFieldId"></string>
           <int value="3"></int>
           <string role="key" value="originalicon"></string>
           <string value=""></string>
           <string role="key" value="parentNode"></string>
           <reference key="20"></reference>
           <string role="key" value="systemResources"></string>
           <list></list>
           <string role="key" value="undo"></string>
           <bool value="1"></bool>
           <string role="key" value="userResources"></string>
           <list></list>
           <string role="key" value="version"></string>
           <int value="0"></int>
          </dictionary>
         </instance>
        </list>
        <string role="key" value="_id"></string>
        <unicode value="11"></unicode>
        <string role="key" value="_package"></string>
        <reference key="1"></reference>
        <string role="key" value="anchor_fields"></string>
        <list></list>
        <string role="key" value="exe.engine.node.Node.persistenceVersion"></string>
        <int value="2"></int>
        <string role="key" value="exportType"></string>
        <string value="website"></string>
        <string role="key" value="last_full_node_path"></string>
        <string value="exe-node:Objektorientierte%20Programmierung:Vererbung"></string>
        <string role="key" value="parent"></string>
        <reference key="5"></reference>
        <string role="key" value="top_anchors_linked_from_fields"></string>
        <list></list>
        <string role="key" value="children"></string>
        <list></list>
       </dictionary>
      </instance>
      <instance class="exe.engine.node.Node" reference="23">
       <dictionary>
        <string role="key" value="_title"></string>
        <unicode value="Abstrakte Klassen und Interfaces"></unicode>
        <string role="key" value="idevices"></string>
        <list>
         <instance class="exe.engine.jsidevice.JsIdevice" reference="21">
          <dictionary>
           <string role="key" value="_title"></string>
           <unicode value=""></unicode>
           <string role="key" value="_attributes"></string>
           <list>
            <tuple>
             <string value="title"></string>
             <list>
              <string value="Title"></string>
              <int value="0"></int>
              <int value="0"></int>
             </list>
            </tuple>
            <tuple>
             <string value="category"></string>
             <list>
              <string value="Category"></string>
              <int value="0"></int>
              <int value="1"></int>
             </list>
            </tuple>
            <tuple>
             <string value="css-class"></string>
             <list>
              <string value="CSS class"></string>
              <int value="0"></int>
              <int value="2"></int>
             </list>
            </tuple>
            <tuple>
             <string value="icon"></string>
             <list>
              <string value="Icon"></string>
              <int value="0"></int>
              <int value="3"></int>
             </list>
            </tuple>
           </list>
           <string role="key" value="_author"></string>
           <string value=""></string>
           <string role="key" value="_iDeviceDir"></string>
           <string value="text"></string>
           <string role="key" value="_purpose"></string>
           <string value=""></string>
           <string role="key" value="_tip"></string>
           <string value=""></string>
           <string role="key" value="_typeName"></string>
           <unicode value="Text"></unicode>
           <string role="key" value="_valid"></string>
           <bool value="1"></bool>
           <string role="key" value="class_"></string>
           <unicode value="text"></unicode>
           <string role="key" value="edit"></string>
           <bool value="0"></bool>
           <string role="key" value="emphasis"></string>
           <int value="0"></int>
           <string role="key" value="exe.engine.jsidevice.JsIdevice.persistenceVersion"></string>
           <int value="1"></int>
           <string role="key" value="fields"></string>
           <list>
            <instance class="exe.engine.field.TextAreaField" reference="22">
             <dictionary>
              <string role="key" value="_id"></string>
              <unicode value="132_2"></unicode>
              <string role="key" value="_idevice"></string>
              <reference key="21"></reference>
              <string role="key" value="_instruc"></string>
              <string value=""></string>
              <string role="key" value="_name"></string>
              <string value=""></string>
              <string role="key" value="anchor_names"></string>
              <list></list>
              <string role="key" value="anchors_linked_from_fields"></string>
              <dictionary></dictionary>
              <string role="key" value="content_w_resourcePaths"></string>
              <unicode content="true" value="&lt;div class=&quot;exe-text&quot;&gt;&lt;p&gt;Abstraktion ist ein zentrales Prinzip der objektorientierten Programmierung, das schon in den bisherigen Kapiteln – von der Einführung in Klassen und Objekte über Vererbung und Polymorphismus – sichtbar wurde. In diesem Kapitel vertiefen wir, wie abstrakte Klassen und Interfaces dazu dienen, gemeinsame Eigenschaften und Verhalten festzulegen, ohne dass jedes Detail explizit implementiert werden muss. Dabei knüpfen wir an den roten Faden der vorangegangenen Kapitel an, indem wir weiterhin praxisnahe und alltagsnahe Beispiele verwenden.&lt;/p&gt;
&lt;h2&gt;Abstrakte Klassen&lt;/h2&gt;
&lt;p&gt;Eine abstrakte Klasse lässt sich am besten als einen Bauplan verstehen, der nicht direkt ein fertiges Produkt liefert, sondern die Grundlagen für mehrere verwandte Produkte bietet. So wie man einen allgemeinen Gebäudeplan besitzt, von dem später spezifische Gebäude (Schule, Krankenhaus, Bibliothek) abgeleitet werden, beschreibt eine abstrakte Klasse gemeinsame Eigenschaften und Methoden, die konkrete Unterklassen übernehmen und erweitern.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Definition und Eigenschaften&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Eine abstrakte Klasse kann sowohl abstrakte Methoden (ohne Implementierung) als auch konkrete Methoden (mit Implementierung) enthalten.&lt;/li&gt;
&lt;li&gt;Sie kann nicht direkt instanziiert werden. Das bedeutet, es ist nicht möglich, ein Objekt direkt von einer abstrakten Klasse zu erzeugen, sondern nur von ihren konkreten Subklassen.&lt;/li&gt;
&lt;li&gt;Abstrakte Klassen ermöglichen es, Gemeinsames zentral zu definieren und gleichzeitig den Unterklassen den Freiraum zu lassen, spezialisierte Implementierungen zu liefern.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Beispiel&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Betrachten wir eine abstrakte Klasse „Tier“, die bereits in früheren Kapiteln zur Veranschaulichung von Vererbung und Polymorphismus verwendet wurde. Hier definieren wir ein gemeinsames Merkmal – das Geräusch – abstrakt, während wir eine konkrete Methode „schlafen“ für alle Tiere umsetzen:&lt;/p&gt;
&lt;div class=&quot;highlighted-code language-java&quot;&gt;
&lt;div&gt;
&lt;pre&gt;&lt;code&gt;// Abstrakte Klasse Tier
public abstract class Tier {
   protected String name;

   public Tier(String name) {
      this.name = name;
   }

   // Abstrakte Methode: keine Implementierung, muss von jeder Subklasse konkret umgesetzt werden
   public abstract void geraeuschMachen();

   // Konkrete Methode: bereitgestellte allgemeine Funktionalität
   public void schlafen() {
      System.out.println(name + &quot; schläft.&quot;);
   }
}

// Konkrete Subklasse Hund
public class Hund extends Tier {
   public Hund(String name) {
      super(name);
   }

   @Override
   public void geraeuschMachen() {
      System.out.println(name + &quot; bellt: Wuff!&quot;);
   }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;In diesem Beispiel dient die abstrakte Klasse „Tier“ dazu, einen Rahmen vorzugeben, ohne sich auf eine spezifische Implementation des Geräuschmachens festzulegen. Jede Tierart kann dann ihre eigene Variante implementieren – so bleibt der Code flexibel und übersichtlich.&lt;/p&gt;
&lt;h2&gt;2. Interfaces&lt;/h2&gt;
&lt;p&gt;Interfaces hingegen können als Verträge verstanden werden, die festlegen, welche Methoden ein Objekt bereitstellen muss – jedoch ohne jegliche Implementierung. Während abstrakte Klassen oft ein „ist-ein“ Verhältnis abbilden, fokussieren sich Interfaces auf das, was ein Objekt „kann“.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Definition und Eigenschaften&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Ein Interface definiert ausschließlich Methodensignaturen (ab Java 8 sind auch Default-Methoden mit Implementierung möglich, jedoch bleibt das Kernelement abstrakt).&lt;/li&gt;
&lt;li&gt;Es kann von beliebig vielen Klassen „implementiert“ werden, was eine Art Mehrfachvererbung ermöglicht, da eine Klasse mehrere Interfaces implementieren kann.&lt;/li&gt;
&lt;li&gt;Interfaces dienen zur Entkoppelung: Sie legen fest, welche Funktionalitäten benötigt werden, ohne die konkrete Implementierung vorzugeben.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Beispiel&lt;/p&gt;
&lt;p&gt;Wir erstellen ein Interface „Bewegbar“, das eine Methode definiert, die von verschiedenen Klassen umgesetzt werden soll, z. B. von Fahrzeugen oder auch von grafischen Elementen in Processing:&lt;/p&gt;
&lt;div class=&quot;highlighted-code language-java&quot;&gt;
&lt;div&gt;
&lt;pre&gt;&lt;code&gt;// Interface Bewegbar
public interface Bewegbar {
   // Methodensignatur, die von jedem implementierenden Objekt definiert werden muss
   void bewegen();
}

// Klasse Auto implementiert das Interface Bewegbar
public class Auto implements Bewegbar {
   private String modell;

   public Auto(String modell) {
      this.modell = modell;
   }

   @Override
   public void bewegen() {
      System.out.println(modell + &quot; fährt auf der Straße.&quot;);
   }
}

// Außerdem könnte auch eine grafische Form, z. B. ein Kreis, Beweglichkeit implementieren
public class Circle implements Bewegbar {
   private float x, y, radius;

   public Circle(float x, float y, float radius) {
      this.x = x;
      this.y = y;
      this.radius = radius;
   }

   @Override
   public void bewegen() {
      // Beispiel: Kreis bewegt sich diagonal
      x += 5;
      y += 5;
      System.out.println(&quot;Kreis bewegt sich zu Position (&quot; + x + &quot;, &quot; + y + &quot;).&quot;);
   }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Durch diese Entkopplung der Implementierung vom Vertrag (Interface) können verschiedene Klassen – ob Fahrzeug oder grafische Form – dieselbe Methode auf unterschiedliche Weise umsetzen und dennoch über einen gemeinsamen Typ angesprochen werden.&lt;/p&gt;
&lt;h2&gt;3. Vergleich: Abstrakte Klassen vs. Interfaces&lt;/h2&gt;
&lt;p&gt;Beide Konzepte dienen der Abstraktion, verfolgen jedoch unterschiedliche Ansätze:&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;table style=&quot;width: 100%; height: 155px;&quot; border=&quot;1&quot;&gt;
&lt;tbody&gt;
&lt;tr style=&quot;height: 25px;&quot;&gt;
&lt;td style=&quot;width: 21.0247%; height: 25px;&quot;&gt;&lt;/td&gt;
&lt;td style=&quot;width: 39.0283%; height: 25px;&quot;&gt;Abstrakte Klasse&lt;/td&gt;
&lt;td style=&quot;width: 39.9469%; height: 25px;&quot;&gt;Interface&lt;/td&gt;
&lt;/tr&gt;
&lt;tr style=&quot;height: 25px;&quot;&gt;
&lt;td style=&quot;width: 21.0247%; height: 25px;&quot;&gt;Instanziierung&lt;/td&gt;
&lt;td style=&quot;width: 39.0283%; height: 25px;&quot;&gt;Kann nicht direkt instanziert werden&lt;/td&gt;
&lt;td style=&quot;width: 39.9469%; height: 25px;&quot;&gt;Kann ebenfalls nicht instanziert werden&lt;/td&gt;
&lt;/tr&gt;
&lt;tr style=&quot;height: 50px;&quot;&gt;
&lt;td style=&quot;width: 21.0247%; height: 50px;&quot;&gt;Implementierung&lt;/td&gt;
&lt;td style=&quot;width: 39.0283%; height: 50px;&quot;&gt;Kann sowohl abstrakte als auch konkrete Methoden enthalten&lt;/td&gt;
&lt;td style=&quot;width: 39.9469%; height: 50px;&quot;&gt;Enthält primär abstrakte Methoden &lt;br /&gt;&lt;span style=&quot;font-size: 10pt;&quot;&gt;(Default-Methoden seit Java 8 möglich)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr style=&quot;height: 25px;&quot;&gt;
&lt;td style=&quot;width: 21.0247%; height: 25px;&quot;&gt;Vererbung&lt;/td&gt;
&lt;td style=&quot;width: 39.0283%; height: 25px;&quot;&gt;Eine Klasse kann nur eine abstrakte Klasse erweitern&lt;/td&gt;
&lt;td style=&quot;width: 39.9469%; height: 25px;&quot;&gt;Eine Klasse kann mehrere Interfaces implementieren&lt;/td&gt;
&lt;/tr&gt;
&lt;tr style=&quot;height: 30px;&quot;&gt;
&lt;td style=&quot;width: 21.0247%; height: 30px;&quot;&gt;Verwendungszweck&lt;/td&gt;
&lt;td style=&quot;width: 39.0283%; height: 30px;&quot;&gt;
&lt;p&gt;Gemeinsame Basis für eng verwandte Klassen, zentraler Code&lt;/p&gt;
&lt;/td&gt;
&lt;td style=&quot;width: 39.9469%; height: 30px;&quot;&gt;Definition eines Vertrages, der von beliebigen Klassen erfüllt werden kann&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;Diese Gegenüberstellung verdeutlicht, dass abstrakte Klassen ideal sind, wenn es eine starke “ist-ein” Beziehung gibt, während Interfaces Flexibilität und lose Kopplung bei der Umsetzung von Fähigkeiten ermöglichen.&lt;/p&gt;
&lt;h2&gt;4. Praxisrelevanz und interdisziplinäre Anwendungen&lt;/h2&gt;
&lt;p&gt;Für Studierende des Medieningenieurwesens sind abstrakte Klassen und Interfaces nicht nur theoretische Konzepte, sondern Werkzeuge, um komplexe, interdisziplinäre Projekte zu realisieren. Beispielsweise kann in einem Mediaprojekt eine abstrakte Klasse „Form“ definiert werden, die eine Methode draw() enthält. Spezifische Formen wie Kreis, Rechteck oder Dreieck implementieren diese Methode jeweils auf ihre Art – was direkt an die in Kapitel 5 vorgestellte Polymorphismusstruktur anknüpft.&lt;/p&gt;
&lt;p&gt;Gleichzeitig kann ein Interface wie „Interaktiv“ festlegen, dass jede Komponente in einer Medienanwendung auch eine Methode handleInput() liefern muss – egal, ob es sich um ein grafisches Objekt, einen Sound oder ein Video handelt. Durch diese Trennung lassen sich komplexe Anwendungen modular entwerfen und flexibel erweitern, ohne dass bereits bestehender Code angepasst werden muss.&lt;/p&gt;
&lt;h1&gt;&lt;br /&gt;Übungen&lt;/h1&gt;
&lt;h2&gt;Aufgaben:&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Aufgabe 1: Abstrakte Klasse implementieren&lt;/strong&gt;&lt;br /&gt;Erstelle eine abstrakte Klasse „Form“ mit folgenden Eigenschaften: spezielle Attribute (z. B. Position und Farbe) und einer abstrakten Methode draw().&lt;br /&gt;Erstelle anschließend zwei konkrete Unterklassen, „Circle“ und „Rectangle“, die die Methode draw() spezifisch umsetzen.&lt;br /&gt;Teste deine Implementierung in einer Main-Methode, in der du ein Array von Form-Objekten iterierst und jeweils draw() aufrufst.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Aufgabe 2: Interface in einem interaktiven Szenario&lt;/strong&gt;&lt;br /&gt;Definiere ein Interface „Interaktiv“ mit der Methode handleInput(String input).&lt;br /&gt;Implementiere zwei Klassen – z. B. „Button“ und „Slider“ – die dieses Interface implementieren.&lt;br /&gt;Schreibe ein Programm, das beide Objekte erstellt und anhand eines Beispiel-Inputs die Methode handleInput() polymorph aufruft.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Fragen:&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Warum kann eine abstrakte Klasse nicht direkt instanziiert werden?&lt;/li&gt;
&lt;li&gt;In welchen Situationen würdest du ein Interface einem abstrakten Klasse vorziehen?&lt;/li&gt;
&lt;li&gt;Nenne zwei wesentliche Unterschiede zwischen abstrakten Klassen und Interfaces.&lt;/li&gt;
&lt;li&gt;Wie fördert die Implementierung von Interfaces die lose Kopplung in einem Softwareprojekt?&lt;/li&gt;
&lt;/ol&gt;
&lt;h1&gt;Zusammenfassung&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Abstrakte Klassen:
&lt;ul&gt;
&lt;li&gt;Dienen als Basis und Bauplan für verwandte Klassen.&lt;/li&gt;
&lt;li&gt;Können sowohl abstrakte Methoden als auch konkrete Implementierungen enthalten.&lt;/li&gt;
&lt;li&gt;Werden genutzt, um eine “ist-ein” Beziehung zu modellieren.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Interfaces:
&lt;ul&gt;
&lt;li&gt;Definieren Verträge, die jede implementierende Klasse erfüllen muss.&lt;/li&gt;
&lt;li&gt;Ermöglichen Mehrfachvererbung in Form von verhaltensbezogener Kopplung.&lt;/li&gt;
&lt;li&gt;Sorgen für flexible und lose gekoppelte Architekturen.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Gemeinsamer Nutzen:
&lt;ul&gt;
&lt;li&gt;Beide Mechanismen unterstützen die Abstraktion und fördern die Wartbarkeit und Erweiterbarkeit von Code.&lt;/li&gt;
&lt;li&gt;Sie ergänzen die Konzepte der Klassen, Objekte, Vererbung und Polymorphismus, die bereits in den vorherigen Kapiteln behandelt wurden.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/p&gt;&lt;/div&gt;"></unicode>
              <string role="key" value="exe.engine.field.Field.persistenceVersion"></string>
              <int value="4"></int>
              <string role="key" value="exe.engine.field.FieldWithResources.persistenceVersion"></string>
              <int value="2"></int>
              <string role="key" value="exe.engine.field.TextAreaField.persistenceVersion"></string>
              <int value="3"></int>
              <string role="key" value="htmlTag"></string>
              <string value="div"></string>
              <string role="key" value="images"></string>
              <instance class="exe.engine.galleryidevice.GalleryImages">
               <dictionary>
                <string role="key" value=".listitems"></string>
                <list></list>
                <string role="key" value="idevice"></string>
                <reference key="22"></reference>
               </dictionary>
              </instance>
              <string role="key" value="intlinks_to_anchors"></string>
              <dictionary></dictionary>
              <string role="key" value="nextImageId"></string>
              <int value="0"></int>
              <string role="key" value="parentNode"></string>
              <reference key="23"></reference>
             </dictionary>
            </instance>
           </list>
           <string role="key" value="icon"></string>
           <unicode value=""></unicode>
           <string role="key" value="id"></string>
           <unicode value="5"></unicode>
           <string role="key" value="ideviceCategory"></string>
           <unicode value="Text and Tasks"></unicode>
           <string role="key" value="lastIdevice"></string>
           <bool value="0"></bool>
           <string role="key" value="nextFieldId"></string>
           <int value="3"></int>
           <string role="key" value="originalicon"></string>
           <string value=""></string>
           <string role="key" value="parentNode"></string>
           <reference key="23"></reference>
           <string role="key" value="systemResources"></string>
           <list></list>
           <string role="key" value="undo"></string>
           <bool value="1"></bool>
           <string role="key" value="userResources"></string>
           <list></list>
           <string role="key" value="version"></string>
           <int value="0"></int>
          </dictionary>
         </instance>
        </list>
        <string role="key" value="_id"></string>
        <unicode value="5"></unicode>
        <string role="key" value="_package"></string>
        <reference key="1"></reference>
        <string role="key" value="anchor_fields"></string>
        <list></list>
        <string role="key" value="exe.engine.node.Node.persistenceVersion"></string>
        <int value="2"></int>
        <string role="key" value="exportType"></string>
        <string value="website"></string>
        <string role="key" value="last_full_node_path"></string>
        <string value="exe-node:Objektorientierte%20Programmierung:Abstrakte%20Klassen%20und%20Interfaces"></string>
        <string role="key" value="parent"></string>
        <reference key="5"></reference>
        <string role="key" value="top_anchors_linked_from_fields"></string>
        <list></list>
        <string role="key" value="children"></string>
        <list></list>
       </dictionary>
      </instance>
      <instance class="exe.engine.node.Node" reference="26">
       <dictionary>
        <string role="key" value="_title"></string>
        <unicode value="Polymorphismus"></unicode>
        <string role="key" value="idevices"></string>
        <list>
         <instance class="exe.engine.jsidevice.JsIdevice" reference="24">
          <dictionary>
           <string role="key" value="_title"></string>
           <unicode value=""></unicode>
           <string role="key" value="_attributes"></string>
           <list>
            <tuple>
             <string value="title"></string>
             <list>
              <string value="Title"></string>
              <int value="0"></int>
              <int value="0"></int>
             </list>
            </tuple>
            <tuple>
             <string value="category"></string>
             <list>
              <string value="Category"></string>
              <int value="0"></int>
              <int value="1"></int>
             </list>
            </tuple>
            <tuple>
             <string value="css-class"></string>
             <list>
              <string value="CSS class"></string>
              <int value="0"></int>
              <int value="2"></int>
             </list>
            </tuple>
            <tuple>
             <string value="icon"></string>
             <list>
              <string value="Icon"></string>
              <int value="0"></int>
              <int value="3"></int>
             </list>
            </tuple>
           </list>
           <string role="key" value="_author"></string>
           <string value=""></string>
           <string role="key" value="_iDeviceDir"></string>
           <string value="text"></string>
           <string role="key" value="_purpose"></string>
           <string value=""></string>
           <string role="key" value="_tip"></string>
           <string value=""></string>
           <string role="key" value="_typeName"></string>
           <unicode value="Text"></unicode>
           <string role="key" value="_valid"></string>
           <bool value="1"></bool>
           <string role="key" value="class_"></string>
           <unicode value="text"></unicode>
           <string role="key" value="edit"></string>
           <bool value="0"></bool>
           <string role="key" value="emphasis"></string>
           <int value="0"></int>
           <string role="key" value="exe.engine.jsidevice.JsIdevice.persistenceVersion"></string>
           <int value="1"></int>
           <string role="key" value="fields"></string>
           <list>
            <instance class="exe.engine.field.TextAreaField" reference="25">
             <dictionary>
              <string role="key" value="_id"></string>
              <unicode value="131_2"></unicode>
              <string role="key" value="_idevice"></string>
              <reference key="24"></reference>
              <string role="key" value="_instruc"></string>
              <string value=""></string>
              <string role="key" value="_name"></string>
              <string value=""></string>
              <string role="key" value="anchor_names"></string>
              <list></list>
              <string role="key" value="anchors_linked_from_fields"></string>
              <dictionary></dictionary>
              <string role="key" value="content_w_resourcePaths"></string>
              <unicode content="true" value="&lt;div class=&quot;exe-text&quot;&gt;&lt;p&gt;Die objektorientierte Programmierung wäre unvollständig ohne das Konzept des Polymorphismus – ein Prinzip, das den Code flexibler und erweiterbarer macht. In diesem Kapitel erfährst du, was Polymorphismus bedeutet, wie er im Code umgesetzt wird und wie du ihn – ganz im Sinne der Wiederverwendbarkeit und Modularität – sinnvoll in deinen Programmen einsetzen kannst. Dabei knüpfen wir an die bereits behandelten Themen wie Vererbung und Methodenüberladung an und zeigen anhand bekannter Beispiele, etwa aus der Tierwelt und grafischen Anwendungen in Processing, wie dasselbe Interface verschiedene Verhaltensweisen annehmen kann.&lt;/p&gt;
&lt;h2&gt;1.Einführung in den Polymorphismus&lt;/h2&gt;
&lt;p&gt;Stell dir vor, du befindest dich in unterschiedlichen Alltagssituationen: Im Klassenzimmer verhältst du dich als Student, im Supermarkt als Kunde und zu Hause als Familienmitglied. Obwohl es sich um dieselbe Person handelt, ändern sich deine Verhaltensweisen in Abhängigkeit der jeweiligen Situation – so spricht man von „Polymorphismus“, dem Phänomen, dass eine Instanz verschiedene Formen annehmen kann.&lt;br /&gt;In der Programmierung bedeutet das, dass eine Variable einer Oberklasse zur Laufzeit auf Objekte unterschiedlicher Subklassen zeigen kann. Dies ermöglicht es, mit einer einheitlichen Schnittstelle auf verschiedene Implementierungen zuzugreifen.&lt;/p&gt;
&lt;h2&gt;2. Grundlagen des Polymorphismus&lt;/h2&gt;
&lt;p&gt;Polymorphismus lässt sich in zwei Hauptbereiche unterteilen:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Statischer&lt;/strong&gt; &lt;strong&gt;Polymorphismus&lt;/strong&gt; (Methodenüberladung):&lt;br /&gt;Hierbei handelt es sich um die Möglichkeit, innerhalb einer Klasse mehrere Methoden mit demselben Namen, aber unterschiedlichen Parametern zu definieren. Die Entscheidung, welche Methode zur Compile-Zeit aufgerufen wird, basiert auf der Signatur der Methode.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Dynamischer Polymorphismus&lt;/strong&gt; (Methodenüberschreibung und dynamische Bindung):&lt;br /&gt;Dynamischer Polymorphismus zeigt sich, wenn eine Methode in einer Subklasse überschrieben wird. Dabei entscheidet erst zur Laufzeit basierend auf dem konkreten Objekttyp, welche Implementierung ausgeführt wird. Dies wird auch als dynamische Bindung bezeichnet.&lt;br /&gt;Ein klassisches Beispiel besteht in der bereits erstellten Tierhierarchie: Auch wenn eine Variable vom Typ Tier deklariert ist, bestimmt das zur Laufzeit zugewiesene Objekt (z. B. Hund oder Katze) das ausgeführte Verhalten der Methode geraeuschMachen(). Dadurch kann derselbe Methodenaufruf unterschiedliche Ergebnisse liefern.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;3. Polymorphismus im Code – Ein praktisches Beispiel&lt;/h2&gt;
&lt;p&gt;&lt;br /&gt;Betrachten wir zunächst ein Beispiel aus der Tierwelt, das wir in Kapitel 4 eröffnet haben. Wir definieren eine Superklasse Tier und zwei Subklassen Hund und Katze, die jeweils die Methode geraeuschMachen() spezifisch implementieren:&lt;/p&gt;
&lt;div class=&quot;highlighted-code language-java&quot;&gt;
&lt;div&gt;
&lt;pre&gt;&lt;code&gt;// Superklasse
public class Tier {
   protected String name;

   public Tier(String name) {
      this.name = name;
   }

   // Eine generische Methode, die in den Subklassen überschrieben wird
   public void geraeuschMachen() {
      System.out.println(&quot;Das Tier macht ein Geräusch.&quot;);
   }
}

// Subklasse Hund
public class Hund extends Tier {&lt;br /&gt;
   public Hund(String name) {
      super(name);
   }

   @Override
   public void geraeuschMachen() {
      System.out.println(name + &quot; bellt: Wuff!&quot;);
   }
}

// Subklasse Katze
public class Katze extends Tier {&lt;br /&gt;
   public Katze(String name) {
      super(name);
   }

   @Override
   public void geraeuschMachen() {
      System.out.println(name + &quot; miaut: Miau!&quot;);
   }
}

// Anwendung in der Main-Methode
public class Main {
   public static void main(String[] args) {
   // Polymorphe Deklaration: Die Referenz vom Typ Tier kann unterschiedliche Objekttypen aufnehmen.
   Tier tier1 = new Hund(&quot;Bello&quot;);
   Tier tier2 = new Katze(&quot;Minka&quot;);

   // Dynamische Bindung – zur Laufzeit wird die geeignete Methode aufgerufen
   tier1.geraeuschMachen(); // Ausgabe: &quot;Bello bellt: Wuff!&quot;
   tier2.geraeuschMachen(); // Ausgabe: &quot;Minka miaut: Miau!&quot;
   }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;In diesem Beispiel zeigt sich deutlich, dass der Typ der Referenz (Tier) nicht ausschlaggebend für das Verhalten ist. Die Methode geraeuschMachen() wird zur Laufzeit „dynamisch gebunden“ und führt die Überschreibung der konkreten Subklassen aus.&lt;/p&gt;
&lt;h2&gt;4. Vergleich zu Vererbung und Methodenüberladung&lt;/h2&gt;
&lt;p&gt;Polymorphismus basiert wesentlich auf den in Kapitel 4 behandelten Prinzipien der Vererbung. Während Vererbung es erlaubt, allgemeine Eigenschaften und Methoden an Subklassen zu übertragen, geht es beim Polymorphismus darum, dass diese geerbten Methoden in den Subklassen auf unterschiedliche Weise umgesetzt werden können.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Vererbung&lt;/strong&gt; liefert den Bauplan und die Übernahme von Eigenschaften.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Methodenüberladung&lt;/strong&gt; (statischer Polymorphismus) ermöglicht es, dass innerhalb derselben Klasse mehrere Methoden mit demselben Namen, aber unterschiedlichen Parametern existieren.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Methodenüberschreibung&lt;/strong&gt; (dynamischer Polymorphismus) sorgt dafür, dass in einer Vererbungshierarchie eine Methode in der Subklasse neu definiert werden kann.&lt;br /&gt;Die Kombination dieser Konzepte ermöglicht es, Programme zu schreiben, bei denen durch einheitliche Schnittstellen unterschiedliche Implementierungen zur Laufzeit gewählt werden – ein entscheidender Vorteil bei der Erweiterung und Pflege von Software.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;5. Polymorphismus in grafischen Anwendungen mit Processing&lt;/h2&gt;
&lt;p&gt;Für Studierende des Medieningenieurwesens ist es besonders interessant zu sehen, wie Polymorphismus in grafischen Anwendungen eingesetzt wird. Angenommen, du entwickelst eine Anwendung in Processing, in der verschiedene Formen dargestellt werden sollen. Du könntest dazu eine abstrakte Superklasse Shape definieren und für jede konkrete Form (Circle, Rectangle, Triangle usw.) die Methode draw() überschreiben:&lt;/p&gt;
&lt;div class=&quot;highlighted-code language-java&quot;&gt;
&lt;div&gt;
&lt;pre&gt;&lt;code&gt;// Abstrakte Oberklasse für grafische Formen
public abstract class Shape {
   protected float x, y;

   public Shape(float x, float y) {
      this.x = x;
      this.y = y;
   }

   // Abstrakte Methode, die von den Subklassen implementiert wird
   public abstract void draw();
}

// Kreis als Subklasse von Shape
public class Circle extends Shape {
   private float radius;

   public Circle(float x, float y, float radius) {
      super(x, y);
      this.radius = radius;
   }

   @Override
   public void draw() {
      // In Processing könnte man hier ellipse(x, y, radius*2, radius*2) aufrufen
      System.out.println(&quot;Zeichne einen Kreis an Position (&quot; + x + &quot;, &quot; + y + &quot;) mit Radius &quot; + radius);
   }
}

// Rechteck als Subklasse von Shape
public class Rectangle extends Shape {
   private float width, height;

   public Rectangle(float x, float y, float width, float height) {
      super(x, y);
      this.width = width;
      this.height = height;
   }

   @Override
   public void draw() {
   // In Processing könnte man hier rect(x, y, width, height) aufrufen
      System.out.println(&quot;Zeichne ein Rechteck an Position (&quot; + x + &quot;, &quot; + y + &quot;) mit Breite &quot; + width + &quot; und Höhe &quot; + height);
   }
}

// Anwendung in der Main-Methode
public class Main {
   public static void main(String[] args) {
      Shape[] shapes = new Shape[2];
      shapes[0] = new Circle(50, 50, 20);
      shapes[1] = new Rectangle(100, 100, 40, 30);

      // Polymorpher Aufruf der draw()-Methode: Je nach konkrete Instanz wird die richtige Methode ausgeführt.
      for (Shape shape : shapes) {
         shape.draw();
      }
   }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Dieses Beispiel demonstriert, wie polymorphe Methodenaufrufe in grafischen Anwendungen Abstraktion und Wiederverwendbarkeit fördern – ein klarer Vorteil, wenn du interaktive Medienprojekte oder Animationen entwickelst.&lt;/p&gt;
&lt;h2&gt;6. Vorteile des Polymorphismus&lt;/h2&gt;
&lt;p&gt;Die Anwendung von Polymorphismus bietet in der Praxis mehrere Vorteile:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Flexibilität&lt;/strong&gt;: Durch die Verwendung gemeinsamer Schnittstellen kannst du Funktionen erstellen, die mit verschiedensten Objekttypen arbeiten.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Erweiterbarkeit&lt;/strong&gt;: Neue Klassen können problemlos in bestehende Hierarchien integriert werden, ohne dass bestehender Code angepasst werden muss.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Wartungsfreundlichkeit&lt;/strong&gt;: Änderungen an einer Methode in der Oberklasse wirken sich auf alle Subklassen aus, sofern diese nicht ausdrücklich überschrieben wurden.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Redundanzreduktion&lt;/strong&gt;: Gemeinsame Logik wird zentral gehalten, während spezifische Unterschiede in den Subklassen behandelt werden.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/p&gt;
&lt;h1&gt;Übungen&lt;/h1&gt;
&lt;h2&gt;&lt;br /&gt;Aufgaben&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Tierhierarchie erweitern:&lt;br /&gt;Erweitere das in Kapitel 4 eingeführte Beispiel. Erstelle zusätzlich zur Klasse Hund und Katze eine weitere Subklasse Vogel, die die Methode geraeuschMachen() überschreibt (z. B. mit der Ausgabe „zwitschert: Zirp,zirp“).&lt;br /&gt;Erstelle in einer Main-Methode ein Array vom Typ Tier, das Objekte aller drei Klassen enthält, und rufe für jedes Objekt die Methode geraeuschMachen() auf.&lt;/li&gt;
&lt;li&gt;Grafische Anwendung in Processing:&lt;br /&gt;Entwickle eine einfache Klassenhierarchie für grafische Formen. Ergänze das Beispiel von Circle und Rectangle um eine weitere Form (z. B. Triangle) und implementiere eine polymorphe draw()-Methode für alle Formen.&lt;br /&gt;Schreibe eine Main-Methode, in der ein Array verschiedener Formen durchlaufen und jede Form gezeichnet wird.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Fragen&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Was versteht man unter dynamischer Bindung im Kontext des Polymorphismus?&lt;/li&gt;
&lt;li&gt;Wie unterscheidet sich das Konzept des Polymorphismus vom statischen Polymorphismus (Methodenüberladung)?&lt;/li&gt;
&lt;li&gt;Welche Vorteile bietet der Einsatz von Polymorphismus in der Softwareentwicklung?&lt;/li&gt;
&lt;li&gt;Warum ist es sinnvoll, in grafischen Anwendungen (wie in Processing) polymorphe Methoden einzusetzen?&lt;/li&gt;
&lt;/ol&gt;
&lt;h1&gt;Zusammenfassung&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Polymorphismus ermöglicht es, dass eine Referenz einer Oberklasse Objekte verschiedener Subklassen zur Laufzeit aufnehmen kann.&lt;/li&gt;
&lt;li&gt;Durch dynamische Bindung wird zur Laufzeit entschieden, welche Methode ausgeführt wird – dies fördert Flexibilität und Wiederverwendbarkeit.&lt;/li&gt;
&lt;li&gt;Methodenüberladung (statischer Polymorphismus) und Methodenüberschreibung (dynamischer Polymorphismus) sind zwei Formen des Polymorphismus.&lt;/li&gt;
&lt;li&gt;Grafische Anwendungen profitieren erheblich von polymorphen Strukturen, da sie eine einheitliche Schnittstelle für unterschiedliche Objekttypen bereitstellen.&lt;/li&gt;
&lt;li&gt;Der Vergleich zu den bereits behandelten Konzepten (Vererbung und Methodenüberladung) zeigt, wie Polymorphismus die Modularität und Erweiterbarkeit verbessert.&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;"></unicode>
              <string role="key" value="exe.engine.field.Field.persistenceVersion"></string>
              <int value="4"></int>
              <string role="key" value="exe.engine.field.FieldWithResources.persistenceVersion"></string>
              <int value="2"></int>
              <string role="key" value="exe.engine.field.TextAreaField.persistenceVersion"></string>
              <int value="3"></int>
              <string role="key" value="htmlTag"></string>
              <string value="div"></string>
              <string role="key" value="images"></string>
              <instance class="exe.engine.galleryidevice.GalleryImages">
               <dictionary>
                <string role="key" value=".listitems"></string>
                <list></list>
                <string role="key" value="idevice"></string>
                <reference key="25"></reference>
               </dictionary>
              </instance>
              <string role="key" value="intlinks_to_anchors"></string>
              <dictionary></dictionary>
              <string role="key" value="nextImageId"></string>
              <int value="0"></int>
              <string role="key" value="parentNode"></string>
              <reference key="26"></reference>
             </dictionary>
            </instance>
           </list>
           <string role="key" value="icon"></string>
           <unicode value=""></unicode>
           <string role="key" value="id"></string>
           <unicode value="4"></unicode>
           <string role="key" value="ideviceCategory"></string>
           <unicode value="Text and Tasks"></unicode>
           <string role="key" value="lastIdevice"></string>
           <bool value="0"></bool>
           <string role="key" value="nextFieldId"></string>
           <int value="3"></int>
           <string role="key" value="originalicon"></string>
           <string value=""></string>
           <string role="key" value="parentNode"></string>
           <reference key="26"></reference>
           <string role="key" value="systemResources"></string>
           <list></list>
           <string role="key" value="undo"></string>
           <bool value="1"></bool>
           <string role="key" value="userResources"></string>
           <list></list>
           <string role="key" value="version"></string>
           <int value="0"></int>
          </dictionary>
         </instance>
        </list>
        <string role="key" value="_id"></string>
        <unicode value="4"></unicode>
        <string role="key" value="_package"></string>
        <reference key="1"></reference>
        <string role="key" value="anchor_fields"></string>
        <list></list>
        <string role="key" value="exe.engine.node.Node.persistenceVersion"></string>
        <int value="2"></int>
        <string role="key" value="exportType"></string>
        <string value="website"></string>
        <string role="key" value="last_full_node_path"></string>
        <string value="exe-node:Objektorientierte%20Programmierung:Polymorphismus"></string>
        <string role="key" value="parent"></string>
        <reference key="5"></reference>
        <string role="key" value="top_anchors_linked_from_fields"></string>
        <list></list>
        <string role="key" value="children"></string>
        <list></list>
       </dictionary>
      </instance>
      <instance class="exe.engine.node.Node" reference="29">
       <dictionary>
        <string role="key" value="_title"></string>
        <unicode value="Design Patterns"></unicode>
        <string role="key" value="idevices"></string>
        <list>
         <instance class="exe.engine.jsidevice.JsIdevice" reference="27">
          <dictionary>
           <string role="key" value="_title"></string>
           <unicode value=""></unicode>
           <string role="key" value="_attributes"></string>
           <list>
            <tuple>
             <string value="title"></string>
             <list>
              <string value="Title"></string>
              <int value="0"></int>
              <int value="0"></int>
             </list>
            </tuple>
            <tuple>
             <string value="category"></string>
             <list>
              <string value="Category"></string>
              <int value="0"></int>
              <int value="1"></int>
             </list>
            </tuple>
            <tuple>
             <string value="css-class"></string>
             <list>
              <string value="CSS class"></string>
              <int value="0"></int>
              <int value="2"></int>
             </list>
            </tuple>
            <tuple>
             <string value="icon"></string>
             <list>
              <string value="Icon"></string>
              <int value="0"></int>
              <int value="3"></int>
             </list>
            </tuple>
           </list>
           <string role="key" value="_author"></string>
           <string value=""></string>
           <string role="key" value="_iDeviceDir"></string>
           <string value="text"></string>
           <string role="key" value="_purpose"></string>
           <string value=""></string>
           <string role="key" value="_tip"></string>
           <string value=""></string>
           <string role="key" value="_typeName"></string>
           <unicode value="Text"></unicode>
           <string role="key" value="_valid"></string>
           <bool value="1"></bool>
           <string role="key" value="class_"></string>
           <unicode value="text"></unicode>
           <string role="key" value="edit"></string>
           <bool value="0"></bool>
           <string role="key" value="emphasis"></string>
           <int value="0"></int>
           <string role="key" value="exe.engine.jsidevice.JsIdevice.persistenceVersion"></string>
           <int value="1"></int>
           <string role="key" value="fields"></string>
           <list>
            <instance class="exe.engine.field.TextAreaField" reference="28">
             <dictionary>
              <string role="key" value="_id"></string>
              <unicode value="133_2"></unicode>
              <string role="key" value="_idevice"></string>
              <reference key="27"></reference>
              <string role="key" value="_instruc"></string>
              <string value=""></string>
              <string role="key" value="_name"></string>
              <string value=""></string>
              <string role="key" value="anchor_names"></string>
              <list></list>
              <string role="key" value="anchors_linked_from_fields"></string>
              <dictionary></dictionary>
              <string role="key" value="content_w_resourcePaths"></string>
              <unicode content="true" value="&lt;div class=&quot;exe-text&quot;&gt;&lt;p&gt;In diesem Kapitel tauchen wir in die Welt der Design Patterns ein – bewährte Lösungsschablonen, die Entwicklern helfen, wiederkehrende Probleme in der objektorientierten Programmierung elegant und effizient zu lösen. Design Patterns bieten nicht nur einen einheitlichen Sprachgebrauch im Team, sondern fördern auch die Wiederverwendbarkeit, Wartbarkeit und Skalierbarkeit des Codes. Anknüpfend an den roten Faden früherer Kapitel – in denen wir beispielsweise Tierhierarchien, grafische Formen und Interaktionen in Processing behandelt haben – werden wir hier ausgewählte Patterns vorstellen, die für Anfänger gut verständlich sind und in interdisziplinären Anwendungsfällen, wie sie im Studiengang Medieningenieur an der Fachhochschule vorkommen, häufig eingesetzt werden.&lt;/p&gt;
&lt;h2&gt;Einführung und Bedeutung von Design Patterns&lt;/h2&gt;
&lt;p&gt;Design Patterns lassen sich am besten mit dem Konzept von Kochrezepten vergleichen. Wie ein Rezept dir vorgibt, welche Zutaten (Klassen, Objekte) in welcher Reihenfolge kombiniert werden müssen, geben Design Patterns erfahrenen Entwicklern einen Leitfaden, um typische Entwurfsprobleme zu lösen. Dabei geht es nicht darum, fertigen Code zu liefern, sondern um flexible Vorlagen, die der konkreten Anwendung angepasst werden können. Besonders in Projekten aus den Bereichen Medien, Elektrotechnik und Informatik helfen Patterns, komplexe Systeme modular zu strukturieren und kommunikative Schnittstellen (Interfaces) sowie gemeinsame Verhaltensweisen einheitlich zu definieren.&lt;/p&gt;
&lt;h2&gt;2. Creational Patterns&lt;/h2&gt;
&lt;p&gt;Der erste Abschnitt widmet sich sogenannten Creational Patterns, also Mustern, die sich mit der objektbezogenen Erzeugung von Instanzen beschäftigen. Hier sollen zwei Muster im Fokus stehen:&lt;/p&gt;
&lt;h3&gt;2.1 Singleton Pattern&lt;/h3&gt;
&lt;p&gt;Das Singleton Pattern stellt sicher, dass eine Klasse nur eine einzige Instanz besitzt und bietet einen globalen Zugriffspunkt darauf. Ein typisches Beispiel ist ein Logger, der in einer Applikation verwendet wird, um Statusmeldungen zu protokollieren – es soll nicht mehrere Logger geben, die in unterschiedlichen Bereichen unabhängig voneinander agieren.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Beispiel:&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;highlighted-code language-java&quot;&gt;
&lt;div&gt;
&lt;pre&gt;&lt;code&gt;public class Logger {
   private static Logger instance;

   // Privater Konstruktor verhindert die direkte Instanziierung
   private Logger() { }

   public static Logger getInstance() {
      if (instance == null) {
         instance = new Logger();
      }
      return instance;
   }

   public void log(String message) {
      System.out.println(&quot;LOG: &quot; + message);
   }
}

// Anwendung in der Main-Methode:
public class Main {
   public static void main(String[] args) {
      Logger logger = Logger.getInstance();
      logger.log(&quot;Anwendung gestartet.&quot;);
   }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h3&gt;2.2 Factory Method Pattern&lt;/h3&gt;
&lt;p&gt;Das Factory Method Pattern bietet eine Schnittstelle zur Erzeugung von Objekten, ohne die genauen Klassen der zu erzeugenden Objekte bekannt geben zu müssen. Anknüpfend an den roten Faden früherer Kapitel, können wir hier beispielsweise eine Factory zur Erzeugung von grafischen Formen nutzen – etwa für die bereits behandelten Formen wie Circle und Rectangle.&lt;/p&gt;
&lt;p&gt;Beispiel:&lt;/p&gt;
&lt;div class=&quot;highlighted-code language-java&quot;&gt;
&lt;div&gt;
&lt;pre&gt;&lt;code&gt;// Gemeinsames Interface für Formen
public interface Shape {
   void draw();
}

// Konkrete Implementierung: Kreis
public class Circle implements Shape {
   @Override
   public void draw() {
      System.out.println(&quot;Zeichne einen Kreis.&quot;);
   }
}

// Konkrete Implementierung: Rechteck
public class Rectangle implements Shape {
   @Override     &lt;br /&gt;   public void draw() {
      System.out.println(&quot;Zeichne ein Rechteck.&quot;);
   }
}

// Factory zur Erstellung von Formen
public class ShapeFactory {
   public Shape createShape(String shapeType) {
      if (shapeType == null) {
         return null;
      }&lt;br /&gt;
      if (shapeType.equalsIgnoreCase(&quot;CIRCLE&quot;)) {
         return new Circle();
      } else if (shapeType.equalsIgnoreCase(&quot;RECTANGLE&quot;)) {
         return new Rectangle();
      }
      return null;
   }
}

// Anwendung in der Main-Methode:
public class Main {
   public static void main(String[] args) {
      ShapeFactory factory = new ShapeFactory();
      Shape shape1 = factory.createShape(&quot;CIRCLE&quot;);
      Shape shape2 = factory.createShape(&quot;RECTANGLE&quot;);
      shape1.draw(); // Ausgabe: &quot;Zeichne einen Kreis.&quot;
      shape2.draw(); // Ausgabe: &quot;Zeichne ein Rechteck.&quot;
   }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h2&gt;&lt;br /&gt;3. Structural Patterns&lt;/h2&gt;
&lt;p&gt;Structural Patterns helfen dabei, Klassen und Objekte zu kombinieren, um größere Strukturen zu schaffen – ähnlich wie Bausteine in einem Baukastensystem, das wir bereits bei der Modellierung von Tierhierarchien oder grafischen Objekten gesehen haben.&lt;/p&gt;
&lt;h3&gt;3.1 Adapter Pattern&lt;/h3&gt;
&lt;p&gt;Das Adapter Pattern ermöglicht es, Klassen mit inkompatiblen Schnittstellen miteinander arbeiten zu lassen. Es funktioniert wie ein Übersetzer zwischen verschiedenen Systemen. Beispielsweise könnte eine bestehende Klasse, die grafische Formen in Processing darstellt, in einen neuen Kontext integriert werden, der ein anderes Interface erwartet.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Beispiel:&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;highlighted-code language-java&quot;&gt;
&lt;div&gt;
&lt;pre&gt;&lt;code&gt;// Angenommen, dies ist eine bestehende Klasse, die eine Form in Processing zeichnet:
public class ProcessingCircle {
   public void drawCircle() {
      System.out.println(&quot;Zeichne Kreis in Processing-Manier.&quot;);
   }
}

// Das gewünschte Interface entspricht dem Shape-Interface:
public interface Shape {
   void draw();
}

// Adapter, der ProcessingCircle in das Shape-Interface einbindet:
public class CircleAdapter implements Shape {
   private ProcessingCircle processingCircle;

   public CircleAdapter(ProcessingCircle processingCircle) {
      this.processingCircle = processingCircle;
   }

   @Override
   public void draw() {
   // Übersetzung des Aufrufs ins entsprechende Processing-Format
      processingCircle.drawCircle();
   }
}

// Anwendung:
public class Main {
   public static void main(String[] args) {
      ProcessingCircle pc = new ProcessingCircle();
      Shape shape = new CircleAdapter(pc);
      shape.draw(); // Ausgabe: &quot;Zeichne Kreis in Processing-Manier.&quot;
   }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h3&gt;3.2 Composite Pattern&lt;/h3&gt;
&lt;p&gt;Das Composite Pattern erlaubt es, Objekte in Baumstrukturen zu organisieren, sodass einzelne Objekte (Blätter) und Gruppen von Objekten (Composite-Objekte) einheitlich behandelt werden können. Im Kontext grafischer Anwendungen kann ein Composite beispielsweise genutzt werden, um komplexe Zusammenstellungen von grafischen Formen (wie Gruppen von Formen) als einzelnes Objekt zu modellieren.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Beispiel:&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;highlighted-code language-java&quot;&gt;
&lt;div&gt;
&lt;pre&gt;&lt;code&gt;import java.util.ArrayList;
import java.util.List;

// Gemeinsame Schnittstelle für alle grafischen Elemente
public interface Graphic {
   void draw();
}

// Blattelement: Einzelne grafische Form
public class Circle implements Graphic {
   @Override
   public void draw() {
      System.out.println(&quot;Zeichne einen Kreis.&quot;);
   }
}

// Composite: Gruppe von grafischen Elementen
public class CompositeGraphic implements Graphic {
   private List&amp;lt;Graphic&amp;gt; graphics = new ArrayList&amp;lt;&amp;gt;();

   public void add(Graphic graphic) {
      graphics.add(graphic);
   }

   @Override
   public void draw() {
      for (Graphic graphic : graphics) {
         graphic.draw();
      }
   }
}

// Anwendung:
public class Main {
   public static void main(String[] args) {
      Circle circle1 = new Circle();
      Circle circle2 = new Circle();
      CompositeGraphic graphicGroup = new CompositeGraphic();
      graphicGroup.add(circle1);
      graphicGroup.add(circle2);
      // Alle enthaltenen Formen werden durch einen einzigen Aufruf gezeichnet:
      graphicGroup.draw();
   }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h2&gt;4. Behavioral Patterns&lt;/h2&gt;
&lt;p&gt;Behavioral Patterns beschäftigen sich mit der Interaktion und Kommunikation zwischen Objekten. Zwei häufig verwendete Muster in diesem Bereich sind:&lt;/p&gt;
&lt;h3&gt;4.1 Observer Pattern&lt;/h3&gt;
&lt;p&gt;Das Observer Pattern ermöglicht es, dass ein Objekt (das Subjekt) seine Beobachter (Observer) automatisch benachrichtigt, wenn sich sein Zustand ändert. Dieses Muster wird häufig in Event-basierter Programmierung genutzt, etwa in grafischen Benutzeroberflächen oder Animationen.&lt;/p&gt;
&lt;p&gt;Beispiel:&lt;/p&gt;
&lt;div class=&quot;highlighted-code language-java&quot;&gt;
&lt;div&gt;
&lt;pre&gt;&lt;code&gt;import java.util.ArrayList;
import java.util.List;

// Subjekt, das Beobachter registriert
public class Subject {
   private List&amp;lt;Observer&amp;gt; observers = new ArrayList&amp;lt;&amp;gt;();
   private String state;

   public void addObserver(Observer observer) {
      observers.add(observer);
   }

   public void setState(String state) {
      this.state = state;
      notifyObservers();
   }

   private void notifyObservers() {
      for (Observer observer : observers) {
         observer.update(state);
      }
   }
}

// Observer-Schnittstelle
public interface Observer {
   void update(String state);
}

// Konkrete Observer
public class ConcreteObserver implements Observer {
   private String name;

   public ConcreteObserver(String name) {
      this.name = name;
   }

   @Override
   public void update(String state) {
      System.out.println(name + &quot; wurde benachrichtigt: Neuer Zustand -&amp;gt; &quot; + state);
   }
}

// Anwendung:
public class Main {
   public static void main(String[] args) {
      Subject subject = new Subject();
      Observer obs1 = new ConcreteObserver(&quot;Observer 1&quot;);
      Observer obs2 = new ConcreteObserver(&quot;Observer 2&quot;);
      subject.addObserver(obs1);
      subject.addObserver(obs2);
      subject.setState(&quot;Aktiv&quot;);
   }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h3&gt;4.2 Strategy Pattern&lt;/h3&gt;
&lt;p&gt;Das Strategy Pattern kapselt verschiedene Algorithmen in separaten Klassen und ermöglicht es dem Klienten, zur Laufzeit zwischen ihnen zu wählen. Dadurch wird der Code flexibler und leichter erweiterbar. Ein praxisnahes Beispiel im Medienkontext könnte die Auswahl unterschiedlicher Zeichenstrategien für grafische Formen sein.&lt;/p&gt;
&lt;p&gt;Beispiel:&lt;/p&gt;
&lt;div class=&quot;highlighted-code language-java&quot;&gt;
&lt;div&gt;
&lt;pre&gt;&lt;code&gt;// Strategy-Schnittstelle, die einen Zeichenalgorithmus definiert
public interface DrawStrategy {
   void draw();
}

// Konkrete Strategien
public class SimpleDrawStrategy implements DrawStrategy {
   @Override
   public void draw() {
      System.out.println(&quot;Zeichne die Form auf einfache Weise.&quot;);
   }
}

public class FancyDrawStrategy implements DrawStrategy {
   @Override
   public void draw() {
      System.out.println(&quot;Zeichne die Form mit aufwändigen Effekten.&quot;);
   }
}

// Kontext, der eine Strategie verwendet
public class ShapeContext {
   private DrawStrategy strategy;

   public ShapeContext(DrawStrategy strategy) {
      this.strategy = strategy;
   }

   public void setStrategy(DrawStrategy strategy) {
      this.strategy = strategy;
   }

   public void executeDraw() {
      strategy.draw();
   }
}

// Anwendung:
public class Main {
   public static void main(String[] args) {
      ShapeContext context = new ShapeContext(new SimpleDrawStrategy());
      context.executeDraw(); // Ausgabe: &quot;Zeichne die Form auf einfache Weise.&quot;
      context.setStrategy(new FancyDrawStrategy());
      context.executeDraw(); // Ausgabe: &quot;Zeichne die Form mit aufwändigen Effekten.&quot;
   }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h1&gt;Übungen&lt;/h1&gt;
&lt;h2&gt;Aufgaben:&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Aufgabe 1:&lt;/strong&gt;&lt;br /&gt;Erstelle eine kleine Anwendung, in der du das Singleton Pattern implementierst (zum Beispiel für einen Logger), und nutze diesen Logger in einem Programm, das verschiedene grafische Formen erzeugt.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Aufgabe 2:&lt;/strong&gt;&lt;br /&gt;Erweitere die bestehende Shape-Fabrik aus Kapitel 2 um eine Composite-Struktur, bei der mehrere Formen zu einer Gruppe zusammengefasst werden können, und implementiere zusätzlich das Observer Pattern, um Änderungen an der Gruppe zu überwachen.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Fragen:&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Welche Vorteile bietet das Singleton Pattern im Vergleich zu normaler Objektinstanziierung?&lt;/li&gt;
&lt;li&gt;Wie unterscheidet sich das Factory Method Pattern vom Singleton Pattern bezüglich der Objekt-Erzeugung?&lt;/li&gt;
&lt;li&gt;Nenne zwei wesentliche Merkmale des Adapter Patterns und erläutere, wie es den Integrationsaufwand reduziert.&lt;/li&gt;
&lt;li&gt;Beschreibe den Unterschied zwischen dem Observer Pattern und dem Strategy Pattern.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;/p&gt;
&lt;h1&gt;Zusammenfassung&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Creational Patterns:
&lt;ul&gt;
&lt;li&gt;Singleton: Sorgt für genau eine Instanz einer Klasse mit globalem Zugriff.&lt;/li&gt;
&lt;li&gt;Factory Method: Erzeugt Objekte, ohne deren konkrete Klasse explizit nennen zu müssen.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Structural Patterns:
&lt;ul&gt;
&lt;li&gt;Adapter: Übersetzt inkompatible Schnittstellen, sodass Klassen zusammenarbeiten können.&lt;/li&gt;
&lt;li&gt;Composite: Organisiert Objekte in Baumstrukturen, sodass Einzelteile und Gruppen einheitlich behandelt werden können.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Behavioral Patterns:
&lt;ul&gt;
&lt;li&gt;Observer: Ermöglicht die automatische Benachrichtigung registrierter Observer bei Zustandsänderungen eines Subjekts.&lt;/li&gt;
&lt;li&gt;Strategy: Kapselt unterschiedliche Algorithmen, so dass zur Laufzeit flexibel zwischen ihnen gewählt werden kann.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Design Patterns stellen wiederverwendbare Lösungsvorlagen dar, die helfen, wiederkehrende Probleme in der Softwareentwicklung zu meistern und den Code flexibel sowie wartbar zu gestalten.&lt;br /&gt;Die vorgestellten Beispiele knüpfen an bereits diskutierte Konzepte (z. B. grafische Formen und Tierhierarchien) an und zeigen, wie die Patterns im interdisziplinären Kontext angewendet werden können.&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;/div&gt;"></unicode>
              <string role="key" value="exe.engine.field.Field.persistenceVersion"></string>
              <int value="4"></int>
              <string role="key" value="exe.engine.field.FieldWithResources.persistenceVersion"></string>
              <int value="2"></int>
              <string role="key" value="exe.engine.field.TextAreaField.persistenceVersion"></string>
              <int value="3"></int>
              <string role="key" value="htmlTag"></string>
              <string value="div"></string>
              <string role="key" value="images"></string>
              <instance class="exe.engine.galleryidevice.GalleryImages">
               <dictionary>
                <string role="key" value=".listitems"></string>
                <list></list>
                <string role="key" value="idevice"></string>
                <reference key="28"></reference>
               </dictionary>
              </instance>
              <string role="key" value="intlinks_to_anchors"></string>
              <dictionary></dictionary>
              <string role="key" value="nextImageId"></string>
              <int value="0"></int>
              <string role="key" value="parentNode"></string>
              <reference key="29"></reference>
             </dictionary>
            </instance>
           </list>
           <string role="key" value="icon"></string>
           <unicode value=""></unicode>
           <string role="key" value="id"></string>
           <unicode value="6"></unicode>
           <string role="key" value="ideviceCategory"></string>
           <unicode value="Text and Tasks"></unicode>
           <string role="key" value="lastIdevice"></string>
           <bool value="0"></bool>
           <string role="key" value="nextFieldId"></string>
           <int value="3"></int>
           <string role="key" value="originalicon"></string>
           <string value=""></string>
           <string role="key" value="parentNode"></string>
           <reference key="29"></reference>
           <string role="key" value="systemResources"></string>
           <list></list>
           <string role="key" value="undo"></string>
           <bool value="1"></bool>
           <string role="key" value="userResources"></string>
           <list></list>
           <string role="key" value="version"></string>
           <int value="0"></int>
          </dictionary>
         </instance>
        </list>
        <string role="key" value="_id"></string>
        <unicode value="6"></unicode>
        <string role="key" value="_package"></string>
        <reference key="1"></reference>
        <string role="key" value="anchor_fields"></string>
        <list></list>
        <string role="key" value="exe.engine.node.Node.persistenceVersion"></string>
        <int value="2"></int>
        <string role="key" value="exportType"></string>
        <string value="website"></string>
        <string role="key" value="last_full_node_path"></string>
        <string value="exe-node:Objektorientierte%20Programmierung:Design%20Patterns"></string>
        <string role="key" value="parent"></string>
        <reference key="5"></reference>
        <string role="key" value="top_anchors_linked_from_fields"></string>
        <list></list>
        <string role="key" value="children"></string>
        <list></list>
       </dictionary>
      </instance>
      <instance class="exe.engine.node.Node" reference="32">
       <dictionary>
        <string role="key" value="_title"></string>
        <unicode value="Programmierprinzipien"></unicode>
        <string role="key" value="idevices"></string>
        <list>
         <instance class="exe.engine.jsidevice.JsIdevice" reference="30">
          <dictionary>
           <string role="key" value="_title"></string>
           <unicode value=""></unicode>
           <string role="key" value="_attributes"></string>
           <list>
            <tuple>
             <string value="title"></string>
             <list>
              <string value="Title"></string>
              <int value="0"></int>
              <int value="0"></int>
             </list>
            </tuple>
            <tuple>
             <string value="category"></string>
             <list>
              <string value="Category"></string>
              <int value="0"></int>
              <int value="1"></int>
             </list>
            </tuple>
            <tuple>
             <string value="css-class"></string>
             <list>
              <string value="CSS class"></string>
              <int value="0"></int>
              <int value="2"></int>
             </list>
            </tuple>
            <tuple>
             <string value="icon"></string>
             <list>
              <string value="Icon"></string>
              <int value="0"></int>
              <int value="3"></int>
             </list>
            </tuple>
           </list>
           <string role="key" value="_author"></string>
           <string value=""></string>
           <string role="key" value="_iDeviceDir"></string>
           <string value="text"></string>
           <string role="key" value="_purpose"></string>
           <string value=""></string>
           <string role="key" value="_tip"></string>
           <string value=""></string>
           <string role="key" value="_typeName"></string>
           <unicode value="Text"></unicode>
           <string role="key" value="_valid"></string>
           <bool value="1"></bool>
           <string role="key" value="class_"></string>
           <unicode value="text"></unicode>
           <string role="key" value="edit"></string>
           <bool value="0"></bool>
           <string role="key" value="emphasis"></string>
           <int value="0"></int>
           <string role="key" value="exe.engine.jsidevice.JsIdevice.persistenceVersion"></string>
           <int value="1"></int>
           <string role="key" value="fields"></string>
           <list>
            <instance class="exe.engine.field.TextAreaField" reference="31">
             <dictionary>
              <string role="key" value="_id"></string>
              <unicode value="144_2"></unicode>
              <string role="key" value="_idevice"></string>
              <reference key="30"></reference>
              <string role="key" value="_instruc"></string>
              <string value=""></string>
              <string role="key" value="_name"></string>
              <string value=""></string>
              <string role="key" value="anchor_names"></string>
              <list></list>
              <string role="key" value="anchors_linked_from_fields"></string>
              <dictionary></dictionary>
              <string role="key" value="content_w_resourcePaths"></string>
              <unicode content="true" value="&lt;div class=&quot;exe-text&quot;&gt;&lt;p&gt;.&lt;/p&gt;
&lt;h2&gt;1. Einleitung&lt;/h2&gt;
&lt;p&gt;Hier folgt das Kapitel Programmierprinzipien – ein umfassender Leitfaden, der zeigt, wie Versionskontrolle und Dokumentation als Grundlage für erfolgreiche Teamprojekte dienen. Wir beleuchten dabei detailliert, wie Git – sowohl über die Kommandozeile als auch direkt in der IntelliJ IDEA – eingesetzt wird, um mittels grundlegender Befehle wie git init, git add, git commit, git push, git pull und git merge den Code in einem kollaborativen Umfeld zu verwalten. Anschließend erklären wir, welche Rolle eine saubere Dokumentation spielt, wie UML-Diagramme und Javadoc-Beispiele konkret umgesetzt werden und welche Folgen unzureichende Dokumentation (etwa ein niedriger Truck-Factor) haben kann&lt;/p&gt;
&lt;p&gt;In interdisziplinären Projekten – etwa im Studiengang Medieningenieur – ist es entscheidend, dass mehrere Teammitglieder gleichzeitig an einer Codebasis arbeiten können. Eine strukturierte Versionskontrolle mittels Git verhindert, dass einzelne Änderungen verloren gehen, und ermöglicht es, den Projektfortschritt jederzeit nachvollziehen zu können. Gleichzeitig stellt eine aussagekräftige Dokumentation sicher, dass neu eingestellte Teammitglieder oder Kollegen schnell den Überblick über die Codearchitektur gewinnen. In diesem Kapitel erfährst du, wie Du beides – Versionskontrolle und Dokumentation – im Rahmen eines größeren Softwareprojekts effizient umsetzt.&lt;/p&gt;
&lt;h2&gt;2. Versionskontrolle und Zusammenarbeit mit Git&lt;/h2&gt;
&lt;h3&gt;2.1 Grundlagen von Git&lt;/h3&gt;
&lt;p&gt;Git ist ein verteiltes Versionskontrollsystem, das den gesamten Projektverlauf als eine Reihe von Snapshots (Commits) speichert. Dabei wird unterschieden in:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Arbeitsverzeichnis (Working Directory): Hier bearbeitest du deine Quellcodedateien.&lt;/li&gt;
&lt;li&gt;Staging Area (Index): In diesem Zwischenspeicher werden selektiv Dateien markiert, die in den nächsten Commit aufgenommen werden sollen.&lt;/li&gt;
&lt;li&gt;Repository: Hier werden alle erstellten Commits dauerhaft gespeichert.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Git speichert Änderungen durch den Einsatz von sogenannten Snapshots. Mit der Trennung in Staging und Commit-Phase hast du die volle Kontrolle darüber, welche Änderungen du dokumentieren möchtest.&lt;/p&gt;
&lt;h3&gt;2.2 Detaillierte Schritt‑für‑Schritt-Anleitungen: Kommandozeile&lt;/h3&gt;
&lt;h4&gt;2.2.1 Git am Anfang: Repository initialisieren&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;Git installieren:&lt;br /&gt;Lade Git von der offiziellen Website (https://git-scm.com) herunter und installiere es.&lt;/li&gt;
&lt;li&gt;Arbeitsverzeichnis anlegen und Repository initialisieren:&lt;br /&gt;Öffne die Kommandozeile, navigiere in das Verzeichnis deines Projekts und führe folgenden Befehl aus:&lt;br /&gt;
&lt;div class=&quot;highlighted-code code-style-2 language-markup&quot;&gt;
&lt;div&gt;
&lt;pre&gt;&lt;code&gt;git init&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
Dadurch wird ein neues Git-Repository (ein versteckter Ordner namens .git) im Projektverzeichnis erstellt.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;2.2.2 Dateien zum Staging-Bereich hinzufügen&lt;/h3&gt;
&lt;p&gt;Bevor du einen Snapshot machst, musst du die Änderungen „stagen“. Dies geschieht mit:&lt;/p&gt;
&lt;div class=&quot;highlighted-code code-style-2 language-markup&quot;&gt;
&lt;div&gt;
&lt;pre&gt;&lt;code&gt;git add &amp;lt;Dateiname&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;oder, um &lt;em&gt;alle&lt;/em&gt; geänderten Dateien hinzuzufügen:&lt;/p&gt;
&lt;div class=&quot;highlighted-code code-style-2 language-markup&quot;&gt;
&lt;div&gt;
&lt;pre&gt;&lt;code&gt;git add .&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Hierbei werden die Änderungen im Staging-Bereich (Index) zusammengetragen.&lt;/p&gt;
&lt;h4&gt;2.2.3 Einen Commit erstellen&lt;/h4&gt;
&lt;p&gt;Nachdem die gewünschten Dateien im Staging-Bereich liegen, erstellst du einen Commit:&lt;/p&gt;
&lt;div class=&quot;highlighted-code code-style-2 language-markup&quot;&gt;
&lt;div&gt;
&lt;pre&gt;&lt;code&gt; git commit -m &quot;Erste Commit-Nachricht: Projekt initialisiert&quot;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Der Commit speichert einen Snapshot der aktuell gestagten Dateien in deiner lokalen Historie. Die Commit-Nachricht sollte kurz und prägnant beschreiben, was geändert wurde.&lt;/p&gt;
&lt;h4&gt;2.2.4 Branches verwalten&lt;/h4&gt;
&lt;p&gt;Um parallel an neuen Features zu arbeiten, werden Branches genutzt:&lt;/p&gt;
&lt;div class=&quot;highlighted-code code-style-2 language-markup&quot;&gt;
&lt;div&gt;
&lt;pre&gt;&lt;code&gt;git branch feature/neues-feature
git checkout feature/neues-feature&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Alternativ:&lt;/p&gt;
&lt;div class=&quot;highlighted-code code-style-2 language-markup&quot;&gt;
&lt;div&gt;
&lt;pre&gt;&lt;code&gt;git checkout -b feature/neues-feature&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Dadurch wird ein neuer Branch erstellt und direkt gewechselt.&lt;/p&gt;
&lt;h4&gt;2.2.5 Änderungen integrieren: Merge&lt;/h4&gt;
&lt;p&gt;Wenn du mit der Arbeit in einem Feature-Branch fertig bist, möchtest du die Änderungen in den Hauptbranch (z. B. main oder master) integrieren:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Wechsle in den Hauptbranch:&lt;br /&gt;
&lt;div class=&quot;highlighted-code code-style-2 language-markup&quot;&gt;
&lt;div&gt;
&lt;pre&gt;&lt;code&gt;git checkout main&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;Führe einen Merge durch:&lt;br /&gt;
&lt;div class=&quot;highlighted-code code-style-2 language-markup&quot;&gt;
&lt;div&gt;
&lt;pre&gt;&lt;code&gt;git merge feature/neues-feature&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Bei einfachen Änderungen werden Merge-Konflikte selten; sollte es jedoch zu Konflikten kommen, zeigt Git an, in welchen Dateien Konflikte vorliegen. In solchen Fällen bearbeitest du die entsprechenden Dateien manuell, markierst die Konfliktbereiche (Git fügt spezielle Markierungen ein) und führst anschließend einen weiteren Commit durch.&lt;/p&gt;
&lt;h4&gt;2.2.6 Remote Repositories: Origin und GitLab&lt;/h4&gt;
&lt;p&gt;Remote Repositories ermöglichen es, dass dein lokales Repository mit einem zentralen Server (z. B. GitLab) synchronisiert wird.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Remote hinzufügen:&lt;br /&gt;Um ein Remote-Repository hinzuzufügen, verwende:&lt;br /&gt;
&lt;div class=&quot;highlighted-code code-style-2 language-markup&quot;&gt;
&lt;div&gt;
&lt;pre&gt;&lt;code&gt;git remote add origin https://gitlab.com/USERNAME/REPOSITORY.git&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
Dabei bezeichnet „origin“ den Standardnamen des Remote-Repositories.&lt;/li&gt;
&lt;li&gt;Änderungen pushen:&lt;br /&gt;Nach dem Hinzufügen des Remotes werden die lokalen Commits ins Remote-Repository übertragen:&lt;br /&gt;
&lt;div class=&quot;highlighted-code code-style-2 language-markup&quot;&gt;
&lt;div&gt;
&lt;pre&gt;&lt;code&gt;git push -u origin main&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
Das -u-Flag setzt den Upstream für den aktuellen Branch, sodass spätere Push- und Pull-Befehle einfacher auszuführen sind.&lt;/li&gt;
&lt;li&gt;Änderungen abrufen:&lt;br /&gt;Um die neuesten Änderungen aus dem Remote-Repository zu erhalten, benutze:&lt;br /&gt;
&lt;div class=&quot;highlighted-code code-style-2 language-markup&quot;&gt;
&lt;div&gt;
&lt;pre&gt;&lt;code&gt;git pull&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
Dieser Befehl führt intern ein git fetch gefolgt von einem git merge durch.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Weitere Remote-Befehle:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;git status: Zeigt den aktuellen Zustand deines Arbeitsverzeichnisses, den Staging-Bereich und die Verbindung zu Remotes an.&lt;/li&gt;
&lt;li&gt;git log: Zeigt die Commit-Historie (mit Hashes, Autor und Nachrichten).&lt;/li&gt;
&lt;li&gt;git diff: Zeigt Unterschiede zwischen Dateien—entweder vor oder nach dem Stagen.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;2.3 Git in der IntelliJ IDEA&lt;/h3&gt;
&lt;p&gt;IntelliJ IDEA bietet eine sehr benutzerfreundliche grafische Oberfläche für Git – ideal für Einsteiger und zur Visualisierung der Git-Historie.&lt;/p&gt;
&lt;h4&gt;2.3.1 Repository in IntelliJ einrichten&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;VCS-Integration aktivieren:&lt;br /&gt;Öffne dein Projekt in IntelliJ IDEA und gehe zu VCS &amp;gt; Enable Version Control Integration. Wähle „Git“ aus.&lt;/li&gt;
&lt;li&gt;Erstes Commit:&lt;br /&gt;Öffne das Commit Fenster (über VCS &amp;gt; Commit oder durch Drücken von Ctrl+K). IntelliJ zeigt dir alle geänderten Dateien an. Wähle diese aus, füge sie zur Staging Area hinzu und schreibe eine Commit-Nachricht. Anschließend kannst du committen und sofort pushen.&lt;/li&gt;
&lt;li&gt;Branch-Verwaltung:&lt;br /&gt;Über das Git-Widget in der rechten unteren Ecke kannst du Branches erstellen, wechseln und mergen. Rechtsklicke auf einen Branch, um Optionen wie Merge oder Rebase auszuwählen.&lt;/li&gt;
&lt;li&gt;Remote Repositories nutzen:&lt;br /&gt;Gehe zu VCS &amp;gt; Git &amp;gt; Remotes und füge den Remote-Repository-Link (z. B. von GitLab) hinzu. Mit den Optionen Push und Pull in der IDE kannst du die Änderungen synchronisieren.&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;2.3.2 Visuelle Darstellung&lt;/h4&gt;
&lt;p&gt;IntelliJ IDEA bietet außerdem visuelle Git-Graphen, die die Commit-Historie und das Branching übersichtlich darstellen. Diese Diagramme helfen, den Entwicklungsfluss nachvollziehbar zu machen und Zusammenführungen (Merge) visuell zu überprüfen.&lt;/p&gt;
&lt;h3&gt;2.4 Kollaborative Git-Arbeit: Pull Requests und Merge-Konflikte&lt;/h3&gt;
&lt;p&gt;In Teamprojekten wird häufig mit Pull Requests (PR) gearbeitet, um Code-Reviews und die Integration von Feature-Branches in den Hauptbranch zu erleichtern.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Pull Request erstellen:&lt;br /&gt;Nachdem ein Feature-Branch in das Remote-Repository gepusht wurde, kann über die Weboberfläche (z. B. auf GitLab) ein PR erstellt werden. Im PR werden die Änderungen zusammengefasst, kommentiert und von anderen Teammitgliedern überprüft, bevor der Merge durchgeführt wird.&lt;/li&gt;
&lt;li&gt;Merge-Konflikte:&lt;br /&gt;Bei paralleler Bearbeitung können Merge-Konflikte auftreten. In diesem Fall zeigt Git an, welche Dateien betroffen sind. Entwickler beheben Konflikte manuell, indem sie die fehlerhaften Abschnitte editieren und den Konfliktbereich anschließend wieder „stagen“ und committen.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;3. Dokumentation – Ein Fundament für Teamprojekte&lt;/h2&gt;
&lt;p&gt;In interdisziplinären Projekten, wie sie im Studiengang Medieningenieur üblich sind, erweist sich eine lückenlose Dokumentation als unabdingbar. Sie dient nicht nur dazu, den Code verständlich und wartbar zu halten, sondern erhöht auch den sogenannten Truck-Factor (auch Bus-Factor genannt) – also die Sicherheit, dass kritisches Wissen nicht nur in den Köpfen einzelner Personen liegt. In diesem Abschnitt befassen wir uns mit zwei wesentlichen Dokumentationsmethoden:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Klassendiagramme (UML)&lt;/li&gt;
&lt;li&gt;Javadoc-Dokumentation&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Beide Instrumente tragen dazu bei, dass Aufgaben, Verantwortlichkeiten und Zusammenhänge in deinem Softwareprojekt transparent und nachvollziehbar dargestellt sind.&lt;/p&gt;
&lt;h3&gt;3.1. UML-Klassendiagramme erstellen&lt;/h3&gt;
&lt;h4&gt;3.1.1 Ziel und Nutzen von Klassendiagrammen&lt;/h4&gt;
&lt;p&gt;Ein UML-Klassendiagramm visualisiert die statische Struktur eines Systems. Es zeigt, welche Klassen (als Baupläne von Objekten) im System existieren, welche Attribute und Methoden sie besitzen und wie sie zueinander in Beziehung stehen (wie etwa Vererbung, Assoziation oder Aggregation). Für Studierende, die bereits in den vorherigen Kapiteln Themen wie Klassen, Objekte und Vererbung kennengelernt haben, bietet das Klassendiagramm eine visuelle Zusammenfassung dieser Konzepte.&lt;/p&gt;
&lt;h4&gt;3.1.2 Grundlegende Elemente eines Klassendiagramms&lt;/h4&gt;
&lt;p&gt;Ein typisches UML-Klassendiagramm besteht aus drei Hauptbereichen in jeder Klassenbox:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Oberer Bereich – Klassenname:
&lt;ul&gt;
&lt;li&gt;Enthält den Namen der Klasse (als Substantiv, z. B. Student, Auto oder Mediaplayer).&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Mittlerer Bereich – Attribute:
&lt;ul&gt;
&lt;li&gt;Listet die Eigenschaften der Klasse auf, wie Variablen oder Datenfelder.&lt;/li&gt;
&lt;li&gt;Jedes Attribut wird oft mit einem Sichtbarkeitsmodifikator versehen:
&lt;ul&gt;
&lt;li&gt;+ für public&lt;/li&gt;
&lt;li&gt;- für private&lt;/li&gt;
&lt;li&gt;# für protected&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Beispiel: -name: String, -alter: int&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Unterer Bereich – Methoden (Operationen):&lt;br /&gt;
&lt;ul&gt;
&lt;li&gt;Zeigt das Verhalten der Klasse, d. h. die Aktionen, die Objekte dieser Klasse ausführen können.&lt;/li&gt;
&lt;li&gt;Auch hier werden Sichtbarkeitsmodifikatoren verwendet, ebenso wie Parameterangaben und Rückgabetypen.&lt;/li&gt;
&lt;li&gt;Beispiel: +getName(): String, +setAlter(int): void&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;3.1.3 Beziehungen und Notationen&lt;/h4&gt;
&lt;p&gt;Neben den inneren Elementen definieren Klassendiagramme auch die Beziehungen zwischen den Klassen. Zu den gängigen Beziehungstypen zählen:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Assoziation:
&lt;ul&gt;
&lt;li&gt;Eine einfache Verbindung zwischen zwei Klassen, z. B. kann ein Student an mehreren Kursen teilnehmen.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Vererbung (Generalization):
&lt;ul&gt;
&lt;li&gt;Zeigt an, dass eine Unterklasse von einer Oberklasse erbt (typisch dargestellt durch einen Pfeil, der von der Unterklasse zur Oberklasse zeigt).&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Aggregation und Komposition:
&lt;ul&gt;
&lt;li&gt;Aggregation steht für eine &quot;hat-ein&quot;-Beziehung, bei der die Teilobjekte auch unabhängig existieren können.&lt;/li&gt;
&lt;li&gt;Komposition hingegen drückt eine starke Bindung aus, bei der das Teil ohne das Ganze nicht existieren kann.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Abhängigkeiten (Dependencies):
&lt;ul&gt;
&lt;li&gt;Temporäre Beziehungen, die z. B. beim Aufrufen von Methoden entstehen können.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;3.1.4 Praktische Anleitung zum Erstellen eines Klassendiagramms&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;Systemüberblick verschaffen:
&lt;ul&gt;
&lt;li&gt;Bestimme den Zweck des Systems (z. B. ein Mediaplayer) und identifiziere die zentralen Klassen (z. B. Playlist, Song, MediaLibrary).&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Klassen und ihre Eigenschaften definieren:
&lt;ul&gt;
&lt;li&gt;Notiere, welche Attribute und Methoden jede Klasse enthalten soll.&lt;/li&gt;
&lt;li&gt;Überlege, welchen Datentyp du für jedes Attribut benötigst (z. B. String, int, boolean).&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Beziehungen festlegen:
&lt;ul&gt;
&lt;li&gt;Bestimme, wie die Klassen miteinander verknüpft sind (z. B. erbt Mediaplayer von einer allgemeinen Klasse Device? Gibt es Assoziationen zwischen Playlist und Song?).&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Diagramm erstellen:
&lt;ul&gt;
&lt;li&gt;Nutze ein UML-Tool wie Lucidchart, draw.io oder PlantUML.&lt;/li&gt;
&lt;li&gt;Ziehe Kästen für jede Klasse auf die Zeichenfläche, trage den Klassennamen, die Attribute und Methoden ein und verbinde die Klassen mit entsprechenden Linien (Pfeile für Vererbung, Linien mit Rauten für Aggregation/Komposition usw.).&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Beachte die Regeln:
&lt;ul&gt;
&lt;li&gt;Halte das Diagramm übersichtlich und vermeide Überladung mit unwichtigen Details.&lt;/li&gt;
&lt;li&gt;Verwende konsistente Namenskonventionen (Klassennamen als Substantive, Methoden als Verben).&lt;/li&gt;
&lt;li&gt;Die Sichtbarkeitsmodifikatoren sollten einheitlich und sinnvoll eingesetzt werden.&lt;/li&gt;
&lt;li&gt;Prüfe, ob alle Beziehungen korrekt dargestellt und verständlich sind.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;3.1.5 Beispiel&lt;/h4&gt;
&lt;p&gt;Ein einfaches Klassendiagramm für einen Mediaplayer könnte so aussehen:&lt;/p&gt;
&lt;p&gt; &lt;br /&gt;text&lt;/p&gt;
&lt;div class=&quot;pre-code&quot;&gt;
&lt;div&gt;
&lt;pre&gt;&lt;code&gt;+-----------------------+
|      MediaPlayer      |
+-----------------------+
| - volume: int         |
| - isPlaying: boolean  |
+-----------------------+
| + play(): void        |
| + pause(): void       |
| + stop(): void        |
+-----------------------+
            ▲
            │
+--------------------------+
|      AdvancedPlayer      |
+--------------------------+
| - equalizerSettings: int |
+--------------------------+
| + adjustEqualizer(): void|
+--------------------------+&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Hier sehen wir, dass AdvancedPlayer von MediaPlayer erbt, dass beide Klassen ihre Attribute und Methoden in getrennten Bereichen aufweisen und die Sichtbarkeit durch Symbole dargestellt wird.&lt;/p&gt;
&lt;h3&gt;3.2. Javadoc-Dokumentation&lt;/h3&gt;
&lt;h4&gt;3.2.1 Grundlagen und Zweck von Javadoc&lt;/h4&gt;
&lt;p&gt;Javadoc ist das standardisierte Tool zur Erzeugung von API-Dokumentationen aus Java-Quellcode. Durch gut strukturierte Javadoc-Kommentare wird der Quellcode nicht nur für andere Entwickler verständlich, sondern auch für die langfristige Wartung des Codes dokumentiert. Dies ist besonders wichtig, wenn Teammitglieder wechseln oder bei der Einarbeitung neuer Mitglieder.&lt;/p&gt;
&lt;h4&gt;2.2 Wie richtet man Javadoc ein?&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Schritt 1: Kommentare im Code integrieren&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Für Klassen, Methoden und Felder fügst du Kommentare im folgenden Format hinzu:&lt;/p&gt;
&lt;div class=&quot;highlighted-code language-java&quot;&gt;
&lt;div&gt;
&lt;pre&gt;&lt;code&gt;/**
* Diese Methode berechnet die Summe von zwei Ganzzahlen.
*
* @param a Die erste Zahl.
* @param b Die zweite Zahl.
* @return Die Summe von a und b.
*/
public int add(int a, int b) {
return a + b;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Achte darauf, beginnend mit /** und endend mit */ zu arbeiten. Verwende Tags wie @param, @return, und @throws, um Parameter, Rückgabewerte und potentielle Exceptions zu dokumentieren.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Schritt 2: Javadoc über die Kommandozeile generieren&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Wechsle in das Verzeichnis, in dem sich dein Quellcode befindet. Führe folgenden Befehl aus, um die Dokumentation zu erstellen:&lt;/p&gt;
&lt;div class=&quot;highlighted-code code-style-2 language-markup&quot;&gt;
&lt;div&gt;
&lt;pre&gt;&lt;code&gt;javadoc -d doc -sourcepath src -subpackages com.meineprojekt&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;-d doc gibt an, dass die HTML-Dateien im Ordner „doc“ erstellt werden sollen.&lt;/li&gt;
&lt;li&gt;-sourcepath src zeigt den Pfad zu deinem Quellcode.&lt;/li&gt;
&lt;li&gt;-subpackages com.meineprojekt sorgt dafür, dass alle Unterpakete des angegebenen Pakets dokumentiert werden.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Schritt 3: Javadoc in der IDE generieren (IntelliJ IDEA)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Öffne dein Projekt in IntelliJ IDEA.&lt;/li&gt;
&lt;li&gt;Gehe zu Tools &amp;gt; Generate JavaDoc….&lt;/li&gt;
&lt;li&gt;Wähle die zu dokumentierenden Module und lege den Zielordner für die HTML-Dokumentation fest.&lt;/li&gt;
&lt;li&gt;Du kannst hier auch erweiterte Optionen anpassen (z. B. Sichtbarkeitsstufen), um festzulegen, welche Klassen und Methoden dokumentiert werden sollen.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;3.2.3 Praktische Hinweise und Tipps&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Regelmäßige Aktualisierung: Füge Javadoc-Kommentare von Beginn an in deinen Code ein und aktualisiere sie bei Änderungen, um eine stets aktuelle Dokumentation zu gewährleisten.&lt;/li&gt;
&lt;li&gt;Vollständigkeit: Jede öffentliche und geschützte Methode sollte kommentiert sein. Dies unterstützt den Wissensaustausch und ist für die spätere Nutzung und Erweiterung unerlässlich.&lt;/li&gt;
&lt;li&gt;Überprüfe die generierte Dokumentation: Oftmals können Tippfehler oder unvollständige Parameterangaben die automatische Dokumentation stören. Schaue dir im Anschluss immer die HTML-Dokumentation an, um Fehler zu erkennen und zu beheben.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;3.4 Folgen mangelnder Dokumentation&lt;/h3&gt;
&lt;p&gt;Fehlende oder unzureichende Dokumentation führt oft zu folgenden Problemen:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Wissensmonopol&lt;/strong&gt;: Nur eine Person kennt die interne Struktur, was das Risiko eines niedrigen Truck-Factors erhöht.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Erhöhter Einarbeitungsaufwand&lt;/strong&gt;: Neue Teammitglieder müssen viel Zeit investieren, um sich in das Codebase einzuarbeiten.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Fehleranfälligkeit&lt;/strong&gt;: Fehlende Erklärungen zu Designentscheidungen können dazu führen, dass Änderungen fehlerhaft oder inkonsistent vorgenommen werden.&lt;br /&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;4. Verbindung von Versionskontrolle und Dokumentation in Teamprojekten&lt;/h2&gt;
&lt;p&gt;Die Kombination aus präziser Versionskontrolle und umfassender Dokumentation ist der Schlüssel zum Erfolg in großen, interdisziplinären Projekten. Während Git dafür sorgt, dass alle Änderungen nachvollziehbar und umkehrbar sind, dokumentiert UML und Javadoc den Inhalt und die Architektur des Projekts. Gemeinsam vermeiden sie das Risiko, unschätzbares Wissen in den Köpfen weniger Teammitglieder zu konzentrieren, und schaffen Transparenz für alle Beteiligten.&lt;/p&gt;
&lt;p&gt;─────────────────────────────────────────────&lt;/p&gt;
&lt;h1&gt;Übungen&lt;/h1&gt;
&lt;h2&gt;Aufgaben&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Aufgabe 1: Git-Repository einrichten und bearbeiten:
&lt;ul&gt;
&lt;li&gt;Erstelle in IntelliJ IDEA ein neues Projekt und initialisiere ein Git-Repository (sowohl über die Kommandozeile als auch über die GUI).&lt;/li&gt;
&lt;li&gt;Führe mehrere Commits durch, indem du Änderungen an Dateien vornimmst, sie mit git add zum Staging hinzufügst und anschließend git commit ausführst.&lt;/li&gt;
&lt;li&gt;Erstelle einen neuen Branch, bearbeite darin eine Datei, löse einen einfachen Merge-Konflikt und merge den Branch in main.&lt;/li&gt;
&lt;li&gt;Füge ein Remote-Repository (z. B. in GitLab) hinzu, pushe deine Commits und erzeuge einen Pull Request, den du anschließend zusammenführst.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Aufgabe 2: Dokumentation erstellen:
&lt;ul&gt;
&lt;li&gt;Erstelle ein UML-Klassendiagramm für ein einfaches Mediaplayer-System mit Klassen wie Playlist, Song und MediaLibrary.&lt;/li&gt;
&lt;li&gt;Ergänze den vorhandenen Java-Code mit ausführlichen Javadoc-Kommentaren und generiere die HTML-Dokumentation.&lt;/li&gt;
&lt;li&gt;Diskutiere in einem kurzen Bericht, welche Konsequenzen fehlender Dokumentation für den Truck-Factor haben kann und welchen Einfluss dies auf die Teamarbeit hat.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Fragen&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Erkläre den Ablauf von git init, git add, git commit und git push. Wie hängen diese Befehle zusammen?&lt;/li&gt;
&lt;li&gt;Was bedeutet der Begriff „staging area“ in Git, und warum ist das Staging vor dem Commit wichtig?&lt;/li&gt;
&lt;li&gt;Wie wird in Git ein Remote-Repository eingerichtet und welchen Namen hat es standardmäßig? Welche Befehle werden verwendet, um Änderungen mit einem Remote-Repository zu synchronisieren?&lt;/li&gt;
&lt;li&gt;Beschreibe, welche Vorteile UML-Diagramme und Javadoc-Dokumentation für die Zusammenarbeit in einem interdisziplinären Team bieten.&lt;/li&gt;
&lt;li&gt;Wie können Pull Requests zu einer höheren Codequalität beitragen und welche Rolle spielen sie im Zusammenführungsprozess von Branches?&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Zusammenfassung&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Git-Grundlagen:
&lt;ul&gt;
&lt;li&gt;Mit git init, git add, git commit und git push werden Änderungen verwaltet und dokumentiert.&lt;/li&gt;
&lt;li&gt;Branches ermöglichen die parallele Bearbeitung, während Merge-Befehle diese Änderungen in den Hauptbranch integrieren.&lt;/li&gt;
&lt;li&gt;Remote-Repositorys (in der Regel unter dem Namen „origin“) sorgen für die Zusammenarbeit über zentrale Server (z. B. GitLab).&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Git in IntelliJ IDEA:
&lt;ul&gt;
&lt;li&gt;Die IDE bietet visuelle Werkzeuge zur Git-Integration, inklusive Menüoptionen zum Committen, Branch-Wechseln und Mergen.&lt;/li&gt;
&lt;li&gt;Es werden beide Arbeitsweisen gezeigt: Kommandozeile und GUI.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Dokumentation:
&lt;ul&gt;
&lt;li&gt;UML-Diagramme visualisieren die Architektur, während Javadoc den Quellcode durch Kommentare dokumentiert.&lt;/li&gt;
&lt;li&gt; Klassendiagramme:
&lt;ul&gt;
&lt;li&gt;Elemente: Klassenname, Attribute, Methoden&lt;/li&gt;
&lt;li&gt;Beziehungen: Vererbung, Assoziation, Aggregation, Komposition, Abhängigkeiten&lt;/li&gt;
&lt;li&gt;Regeln: Klare Struktur, konsistente Notation (Sichtbarkeitsmodifikatoren), übersichtliche Anordnung, nur relevante Informationen darstellen&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Javadoc:
&lt;ul&gt;
&lt;li&gt;Einrichtung: Kommentare mit /** ... */ direkt im Code, Nutzung von Tags wie @param, @return und @throws&lt;/li&gt;
&lt;li&gt;Generierung: Verwendung des javadoc-Befehls über die Kommandozeile (z. B. javadoc -d doc -sourcepath src -subpackages &amp;lt;paketname&amp;gt;) oder über die IDE (IntelliJ IDEA: Tools &amp;gt; Generate JavaDoc…)&lt;/li&gt;
&lt;li&gt;Ziel: Vollständige, strukturierte und stets gepflegte API-Dokumentation, die den Wissenstransfer im Team erleichtert&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Eine lückenlose Dokumentation erhöht den Truck-Factor und erleichtert die Einarbeitung und Zusammenarbeit.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Kollaborative Entwicklung:
&lt;ul&gt;
&lt;li&gt;Praktiken wie Pull Requests und Pair Programming fördern den Wissensaustausch und die Codequalität.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/p&gt;&lt;/div&gt;"></unicode>
              <string role="key" value="exe.engine.field.Field.persistenceVersion"></string>
              <int value="4"></int>
              <string role="key" value="exe.engine.field.FieldWithResources.persistenceVersion"></string>
              <int value="2"></int>
              <string role="key" value="exe.engine.field.TextAreaField.persistenceVersion"></string>
              <int value="3"></int>
              <string role="key" value="htmlTag"></string>
              <string value="div"></string>
              <string role="key" value="images"></string>
              <instance class="exe.engine.galleryidevice.GalleryImages">
               <dictionary>
                <string role="key" value=".listitems"></string>
                <list></list>
                <string role="key" value="idevice"></string>
                <reference key="31"></reference>
               </dictionary>
              </instance>
              <string role="key" value="intlinks_to_anchors"></string>
              <dictionary></dictionary>
              <string role="key" value="nextImageId"></string>
              <int value="0"></int>
              <string role="key" value="parentNode"></string>
              <reference key="32"></reference>
             </dictionary>
            </instance>
           </list>
           <string role="key" value="icon"></string>
           <unicode value=""></unicode>
           <string role="key" value="id"></string>
           <unicode value="18"></unicode>
           <string role="key" value="ideviceCategory"></string>
           <unicode value="Text and Tasks"></unicode>
           <string role="key" value="lastIdevice"></string>
           <bool value="0"></bool>
           <string role="key" value="nextFieldId"></string>
           <int value="3"></int>
           <string role="key" value="originalicon"></string>
           <string value=""></string>
           <string role="key" value="parentNode"></string>
           <reference key="32"></reference>
           <string role="key" value="systemResources"></string>
           <list></list>
           <string role="key" value="undo"></string>
           <bool value="1"></bool>
           <string role="key" value="userResources"></string>
           <list></list>
           <string role="key" value="version"></string>
           <int value="0"></int>
          </dictionary>
         </instance>
        </list>
        <string role="key" value="_id"></string>
        <unicode value="12"></unicode>
        <string role="key" value="_package"></string>
        <reference key="1"></reference>
        <string role="key" value="anchor_fields"></string>
        <list></list>
        <string role="key" value="exe.engine.node.Node.persistenceVersion"></string>
        <int value="2"></int>
        <string role="key" value="exportType"></string>
        <string value="website"></string>
        <string role="key" value="last_full_node_path"></string>
        <string value="exe-node:Objektorientierte%20Programmierung:Programmierprinzipien"></string>
        <string role="key" value="parent"></string>
        <reference key="5"></reference>
        <string role="key" value="top_anchors_linked_from_fields"></string>
        <list></list>
        <string role="key" value="children"></string>
        <list></list>
       </dictionary>
      </instance>
     </list>
    </dictionary>
   </instance>
   <unicode role="key" value="1"></unicode>
   <reference key="4"></reference>
   <unicode role="key" value="11"></unicode>
   <reference key="20"></reference>
   <unicode role="key" value="12"></unicode>
   <reference key="32"></reference>
   <unicode role="key" value="2"></unicode>
   <reference key="8"></reference>
   <unicode role="key" value="3"></unicode>
   <reference key="17"></reference>
   <unicode role="key" value="4"></unicode>
   <reference key="26"></reference>
   <unicode role="key" value="5"></unicode>
   <reference key="23"></reference>
   <unicode role="key" value="6"></unicode>
   <reference key="29"></reference>
   <unicode role="key" value="7"></unicode>
   <reference key="11"></reference>
   <unicode role="key" value="8"></unicode>
   <reference key="14"></reference>
  </dictionary>
  <string role="key" value="_objectives"></string>
  <unicode value=""></unicode>
  <string role="key" value="_preknowledge"></string>
  <unicode value=""></unicode>
  <string role="key" value="_templateFile"></string>
  <string value="Base"></string>
  <string role="key" value="backgroundImgTile"></string>
  <bool value="0"></bool>
  <string role="key" value="currentNode"></string>
  <reference key="32"></reference>
  <string role="key" value="dublinCore"></string>
  <instance class="exe.engine.package.DublinCore">
   <dictionary>
    <string role="key" value="contributors"></string>
    <unicode value=""></unicode>
    <string role="key" value="coverage"></string>
    <unicode value=""></unicode>
    <string role="key" value="creator"></string>
    <unicode value="Jacqueline Rähse"></unicode>
    <string role="key" value="date"></string>
    <unicode value=""></unicode>
    <string role="key" value="description"></string>
    <unicode value="Das Skript zur Lehrveranstaltung Objektorientierte Programmierung im Studiengang Medieningenieur an der Fachhochschule Kiel"></unicode>
    <string role="key" value="format"></string>
    <unicode value=""></unicode>
    <string role="key" value="identifier"></string>
    <unicode value="4a7d755e-34a5-410a-a7d4-601881136623"></unicode>
    <string role="key" value="language"></string>
    <unicode value="de"></unicode>
    <string role="key" value="publisher"></string>
    <unicode value=""></unicode>
    <string role="key" value="relation"></string>
    <unicode value=""></unicode>
    <string role="key" value="rights"></string>
    <unicode value=""></unicode>
    <string role="key" value="source"></string>
    <unicode value=""></unicode>
    <string role="key" value="subject"></string>
    <unicode value=""></unicode>
    <string role="key" value="title"></string>
    <unicode value="Objektorientierte Programmierung Skript"></unicode>
    <string role="key" value="type"></string>
    <unicode value=""></unicode>
   </dictionary>
  </instance>
  <string role="key" value="exe.engine.package.Package.persistenceVersion"></string>
  <int value="16"></int>
  <string role="key" value="exportMetadataType"></string>
  <string value="LOMES"></string>
  <string role="key" value="exportSource"></string>
  <bool value="1"></bool>
  <string role="key" value="footer"></string>
  <string value=""></string>
  <string role="key" value="isLoading"></string>
  <bool value="0"></bool>
  <string role="key" value="license"></string>
  <unicode value="creative commons: attribution - share alike 4.0"></unicode>
  <string role="key" value="lom"></string>
  <instance class="exe.engine.lom.lomsubs.lomSub">
   <dictionary>
    <string role="key" value="__index__"></string>
    <dictionary></dictionary>
    <string role="key" value="__oldchild__"></string>
    <none></none>
    <string role="key" value="annotation"></string>
    <list></list>
    <string role="key" value="classification"></string>
    <list></list>
    <string role="key" value="educational"></string>
    <list>
     <instance class="exe.engine.lom.lomsubs.educationalSub">
      <dictionary>
       <string role="key" value="cognitiveProcess"></string>
       <list></list>
       <string role="key" value="context"></string>
       <list></list>
       <string role="key" value="description"></string>
       <list></list>
       <string role="key" value="difficulty"></string>
       <none></none>
       <string role="key" value="intendedEndUserRole"></string>
       <list></list>
       <string role="key" value="interactivityLevel"></string>
       <none></none>
       <string role="key" value="interactivityType"></string>
       <none></none>
       <string role="key" value="language"></string>
       <list>
        <instance class="exe.engine.lom.lomsubs.LanguageIdSub">
         <dictionary>
          <string role="key" value="extensiontype_"></string>
          <none></none>
          <string role="key" value="valueOf_"></string>
          <string value="de"></string>
         </dictionary>
        </instance>
       </list>
       <string role="key" value="learningResourceType"></string>
       <list></list>
       <string role="key" value="semanticDensity"></string>
       <none></none>
       <string role="key" value="typicalAgeRange"></string>
       <list></list>
       <string role="key" value="typicalLearningTime"></string>
       <none></none>
      </dictionary>
     </instance>
    </list>
    <string role="key" value="general"></string>
    <instance class="exe.engine.lom.lomsubs.generalSub">
     <dictionary>
      <string role="key" value="aggregationLevel"></string>
      <instance class="exe.engine.lom.lomsubs.aggregationLevelSub">
       <dictionary>
        <string role="key" value="extensiontype_"></string>
        <none></none>
        <string role="key" value="source"></string>
        <instance class="exe.engine.lom.lomsubs.sourceValueSub">
         <dictionary>
          <string role="key" value="extensiontype_"></string>
          <none></none>
          <string role="key" value="string"></string>
          <list></list>
          <string role="key" value="uniqueElementName"></string>
          <string value="source"></string>
          <string role="key" value="valueOf_"></string>
          <string value="LOMv1.0"></string>
         </dictionary>
        </instance>
        <string role="key" value="uniqueElementName"></string>
        <string value="aggregationLevel"></string>
        <string role="key" value="value"></string>
        <instance class="exe.engine.lom.lomsubs.aggregationLevelValueSub">
         <dictionary>
          <string role="key" value="extensiontype_"></string>
          <none></none>
          <string role="key" value="source"></string>
          <none></none>
          <string role="key" value="uniqueElementName"></string>
          <string value="value"></string>
          <string role="key" value="value"></string>
          <none></none>
          <string role="key" value="valueOf_"></string>
          <string value="2"></string>
         </dictionary>
        </instance>
       </dictionary>
      </instance>
      <string role="key" value="coverage"></string>
      <list></list>
      <string role="key" value="description"></string>
      <list>
       <instance class="exe.engine.lom.lomsubs.descriptionSub">
        <dictionary>
         <string role="key" value="extensiontype_"></string>
         <none></none>
         <string role="key" value="string"></string>
         <list>
          <instance class="exe.engine.lom.lomsubs.LangStringSub">
           <dictionary>
            <string role="key" value="language"></string>
            <string value="de"></string>
            <string role="key" value="valueOf_"></string>
            <string value="Das Skript zur Lehrveranstaltung Objektorientierte Programmierung im Studiengang Medieningenieur an der Fachhochschule Kiel"></string>
           </dictionary>
          </instance>
         </list>
        </dictionary>
       </instance>
      </list>
      <string role="key" value="identifier"></string>
      <list>
       <instance class="exe.engine.lom.lomsubs.identifierSub">
        <dictionary>
         <string role="key" value="catalog"></string>
         <instance class="exe.engine.lom.lomsubs.catalogSub">
          <dictionary>
           <string role="key" value="uniqueElementName"></string>
           <string value="catalog"></string>
           <string role="key" value="valueOf_"></string>
           <unicode value="My Catalog"></unicode>
          </dictionary>
         </instance>
         <string role="key" value="entry"></string>
         <instance class="exe.engine.lom.lomsubs.entrySub">
          <dictionary>
           <string role="key" value="uniqueElementName"></string>
           <string value="entry"></string>
           <string role="key" value="valueOf_"></string>
           <unicode value="4a7d755e-34a5-410a-a7d4-601881136623"></unicode>
          </dictionary>
         </instance>
        </dictionary>
       </instance>
      </list>
      <string role="key" value="keyword"></string>
      <list></list>
      <string role="key" value="language"></string>
      <list>
       <instance class="exe.engine.lom.lomsubs.LanguageIdSub">
        <dictionary>
         <string role="key" value="extensiontype_"></string>
         <none></none>
         <string role="key" value="valueOf_"></string>
         <string value="de"></string>
        </dictionary>
       </instance>
      </list>
      <string role="key" value="structure"></string>
      <none></none>
      <string role="key" value="title"></string>
      <instance class="exe.engine.lom.lomsubs.titleSub">
       <dictionary>
        <string role="key" value="extensiontype_"></string>
        <none></none>
        <string role="key" value="string"></string>
        <list>
         <instance class="exe.engine.lom.lomsubs.LangStringSub">
          <dictionary>
           <string role="key" value="language"></string>
           <string value="de"></string>
           <string role="key" value="valueOf_"></string>
           <string value="Objektorientierte Programmierung Skript"></string>
          </dictionary>
         </instance>
        </list>
        <string role="key" value="uniqueElementName"></string>
        <none></none>
       </dictionary>
      </instance>
      <string role="key" value="uniqueElementName"></string>
      <string value="general"></string>
     </dictionary>
    </instance>
    <string role="key" value="lifeCycle"></string>
    <instance class="exe.engine.lom.lomsubs.lifeCycleSub">
     <dictionary>
      <string role="key" value="contribute"></string>
      <list>
       <instance class="exe.engine.lom.lomsubs.contributeSub">
        <dictionary>
         <string role="key" value="date"></string>
         <instance class="exe.engine.lom.lomsubs.dateSub">
          <dictionary>
           <string role="key" value="dateTime"></string>
           <instance class="exe.engine.lom.lomsubs.DateTimeValueSub">
            <dictionary>
             <string role="key" value="uniqueElementName"></string>
             <string value="dateTime"></string>
             <string role="key" value="valueOf_"></string>
             <string value="2025-01-28T12:09:36.00+01:00"></string>
            </dictionary>
           </instance>
           <string role="key" value="description"></string>
           <instance class="exe.engine.lom.lomsubs.LanguageStringSub">
            <dictionary>
             <string role="key" value="extensiontype_"></string>
             <none></none>
             <string role="key" value="string"></string>
             <list>
              <instance class="exe.engine.lom.lomsubs.LangStringSub">
               <dictionary>
                <string role="key" value="language"></string>
                <string value="de"></string>
                <string role="key" value="valueOf_"></string>
                <string value="Erstellungsdatum des Metadatenschemas"></string>
               </dictionary>
              </instance>
             </list>
            </dictionary>
           </instance>
           <string role="key" value="extensiontype_"></string>
           <none></none>
           <string role="key" value="uniqueElementName"></string>
           <none></none>
           <string role="key" value="valueOf_"></string>
           <none></none>
          </dictionary>
         </instance>
         <string role="key" value="entity"></string>
         <list>
          <instance class="exe.engine.lom.lomsubs.entitySub">
           <dictionary>
            <string role="key" value="extensiontype_"></string>
            <none></none>
            <string role="key" value="valueOf_"></string>
            <string value="BEGIN:VCARD VERSION:3.0 FN:Jacqueline R\xc3\xa4hse EMAIL;TYPE=INTERNET: ORG: END:VCARD"></string>
           </dictionary>
          </instance>
         </list>
         <string role="key" value="role"></string>
         <instance class="exe.engine.lom.lomsubs.roleSub">
          <dictionary>
           <string role="key" value="extensiontype_"></string>
           <none></none>
           <string role="key" value="source"></string>
           <instance class="exe.engine.lom.lomsubs.sourceValueSub">
            <dictionary>
             <string role="key" value="extensiontype_"></string>
             <none></none>
             <string role="key" value="string"></string>
             <list></list>
             <string role="key" value="uniqueElementName"></string>
             <string value="source"></string>
             <string role="key" value="valueOf_"></string>
             <string value="LOMv1.0"></string>
            </dictionary>
           </instance>
           <string role="key" value="uniqueElementName"></string>
           <string value="role"></string>
           <string role="key" value="value"></string>
           <instance class="exe.engine.lom.lomsubs.roleValueSub">
            <dictionary>
             <string role="key" value="extensiontype_"></string>
             <none></none>
             <string role="key" value="source"></string>
             <none></none>
             <string role="key" value="uniqueElementName"></string>
             <string value="value"></string>
             <string role="key" value="value"></string>
             <none></none>
             <string role="key" value="valueOf_"></string>
             <string value="author"></string>
            </dictionary>
           </instance>
          </dictionary>
         </instance>
        </dictionary>
       </instance>
      </list>
      <string role="key" value="status"></string>
      <none></none>
      <string role="key" value="uniqueElementName"></string>
      <none></none>
      <string role="key" value="version"></string>
      <none></none>
     </dictionary>
    </instance>
    <string role="key" value="metaMetadata"></string>
    <instance class="exe.engine.lom.lomsubs.metaMetadataSub">
     <dictionary>
      <string role="key" value="contribute"></string>
      <list>
       <instance class="exe.engine.lom.lomsubs.contributeMetaSub">
        <dictionary>
         <string role="key" value="date"></string>
         <instance class="exe.engine.lom.lomsubs.dateSub">
          <dictionary>
           <string role="key" value="dateTime"></string>
           <instance class="exe.engine.lom.lomsubs.DateTimeValueSub">
            <dictionary>
             <string role="key" value="uniqueElementName"></string>
             <string value="dateTime"></string>
             <string role="key" value="valueOf_"></string>
             <string value="2025-01-28T12:05:28.00+01:00"></string>
            </dictionary>
           </instance>
           <string role="key" value="description"></string>
           <instance class="exe.engine.lom.lomsubs.LanguageStringSub">
            <dictionary>
             <string role="key" value="extensiontype_"></string>
             <none></none>
             <string role="key" value="string"></string>
             <list>
              <instance class="exe.engine.lom.lomsubs.LangStringSub">
               <dictionary>
                <string role="key" value="language"></string>
                <string value="de"></string>
                <string role="key" value="valueOf_"></string>
                <string value="Erstellungsdatum des Metadatenschemas"></string>
               </dictionary>
              </instance>
             </list>
            </dictionary>
           </instance>
           <string role="key" value="extensiontype_"></string>
           <none></none>
           <string role="key" value="uniqueElementName"></string>
           <none></none>
           <string role="key" value="valueOf_"></string>
           <none></none>
          </dictionary>
         </instance>
         <string role="key" value="entity"></string>
         <list>
          <instance class="exe.engine.lom.lomsubs.entitySub">
           <dictionary>
            <string role="key" value="extensiontype_"></string>
            <none></none>
            <string role="key" value="valueOf_"></string>
            <string value="BEGIN:VCARD VERSION:3.0 FN:Jacqueline R\xc3\xa4hse EMAIL;TYPE=INTERNET: ORG: END:VCARD"></string>
           </dictionary>
          </instance>
         </list>
         <string role="key" value="role"></string>
         <instance class="exe.engine.lom.lomsubs.roleSub">
          <dictionary>
           <string role="key" value="extensiontype_"></string>
           <none></none>
           <string role="key" value="source"></string>
           <instance class="exe.engine.lom.lomsubs.sourceValueSub">
            <dictionary>
             <string role="key" value="extensiontype_"></string>
             <none></none>
             <string role="key" value="string"></string>
             <list></list>
             <string role="key" value="uniqueElementName"></string>
             <string value="source"></string>
             <string role="key" value="valueOf_"></string>
             <string value="LOMv1.0"></string>
            </dictionary>
           </instance>
           <string role="key" value="uniqueElementName"></string>
           <string value="role"></string>
           <string role="key" value="value"></string>
           <instance class="exe.engine.lom.lomsubs.roleValueSub">
            <dictionary>
             <string role="key" value="extensiontype_"></string>
             <none></none>
             <string role="key" value="source"></string>
             <none></none>
             <string role="key" value="uniqueElementName"></string>
             <string value="value"></string>
             <string role="key" value="value"></string>
             <none></none>
             <string role="key" value="valueOf_"></string>
             <string value="creator"></string>
            </dictionary>
           </instance>
          </dictionary>
         </instance>
        </dictionary>
       </instance>
      </list>
      <string role="key" value="identifier"></string>
      <list></list>
      <string role="key" value="language"></string>
      <instance class="exe.engine.lom.lomsubs.LanguageIdSub">
       <dictionary>
        <string role="key" value="extensiontype_"></string>
        <none></none>
        <string role="key" value="valueOf_"></string>
        <string value="de"></string>
       </dictionary>
      </instance>
      <string role="key" value="metadataSchema"></string>
      <list>
       <instance class="exe.engine.lom.lomsubs.metadataSchemaSub">
        <dictionary>
         <string role="key" value="valueOf_"></string>
         <string value="LOMv1.0"></string>
        </dictionary>
       </instance>
      </list>
      <string role="key" value="uniqueElementName"></string>
      <string value="metaMetadata"></string>
     </dictionary>
    </instance>
    <string role="key" value="relation"></string>
    <list></list>
    <string role="key" value="rights"></string>
    <instance class="exe.engine.lom.lomsubs.rightsSub">
     <dictionary>
      <string role="key" value="access"></string>
      <none></none>
      <string role="key" value="copyrightAndOtherRestrictions"></string>
      <instance class="exe.engine.lom.lomsubs.copyrightAndOtherRestrictionsSub">
       <dictionary>
        <string role="key" value="extensiontype_"></string>
        <none></none>
        <string role="key" value="source"></string>
        <instance class="exe.engine.lom.lomsubs.sourceValueSub">
         <dictionary>
          <string role="key" value="extensiontype_"></string>
          <none></none>
          <string role="key" value="string"></string>
          <list></list>
          <string role="key" value="uniqueElementName"></string>
          <string value="source"></string>
          <string role="key" value="valueOf_"></string>
          <string value="LOMv1.0"></string>
         </dictionary>
        </instance>
        <string role="key" value="uniqueElementName"></string>
        <string value="copyrightAndOtherRestrictions"></string>
        <string role="key" value="value"></string>
        <instance class="exe.engine.lom.lomsubs.copyrightAndOtherRestrictionsValueSub">
         <dictionary>
          <string role="key" value="extensiontype_"></string>
          <none></none>
          <string role="key" value="source"></string>
          <none></none>
          <string role="key" value="uniqueElementName"></string>
          <string value="value"></string>
          <string role="key" value="value"></string>
          <none></none>
          <string role="key" value="valueOf_"></string>
          <string value="yes"></string>
         </dictionary>
        </instance>
       </dictionary>
      </instance>
      <string role="key" value="cost"></string>
      <none></none>
      <string role="key" value="description"></string>
      <none></none>
      <string role="key" value="uniqueElementName"></string>
      <none></none>
     </dictionary>
    </instance>
    <string role="key" value="technical"></string>
    <none></none>
   </dictionary>
  </instance>
  <string role="key" value="lomEs"></string>
  <instance class="exe.engine.lom.lomsubs.lomSub">
   <dictionary>
    <string role="key" value="__index__"></string>
    <dictionary></dictionary>
    <string role="key" value="__oldchild__"></string>
    <none></none>
    <string role="key" value="annotation"></string>
    <list></list>
    <string role="key" value="classification"></string>
    <list></list>
    <string role="key" value="educational"></string>
    <list>
     <instance class="exe.engine.lom.lomsubs.educationalSub">
      <dictionary>
       <string role="key" value="cognitiveProcess"></string>
       <list></list>
       <string role="key" value="context"></string>
       <list></list>
       <string role="key" value="description"></string>
       <list></list>
       <string role="key" value="difficulty"></string>
       <none></none>
       <string role="key" value="intendedEndUserRole"></string>
       <list></list>
       <string role="key" value="interactivityLevel"></string>
       <none></none>
       <string role="key" value="interactivityType"></string>
       <none></none>
       <string role="key" value="language"></string>
       <list>
        <instance class="exe.engine.lom.lomsubs.LanguageIdSub">
         <dictionary>
          <string role="key" value="extensiontype_"></string>
          <none></none>
          <string role="key" value="valueOf_"></string>
          <string value="de"></string>
         </dictionary>
        </instance>
       </list>
       <string role="key" value="learningResourceType"></string>
       <list></list>
       <string role="key" value="semanticDensity"></string>
       <none></none>
       <string role="key" value="typicalAgeRange"></string>
       <list></list>
       <string role="key" value="typicalLearningTime"></string>
       <none></none>
      </dictionary>
     </instance>
    </list>
    <string role="key" value="general"></string>
    <instance class="exe.engine.lom.lomsubs.generalSub">
     <dictionary>
      <string role="key" value="aggregationLevel"></string>
      <instance class="exe.engine.lom.lomsubs.aggregationLevelSub">
       <dictionary>
        <string role="key" value="extensiontype_"></string>
        <none></none>
        <string role="key" value="source"></string>
        <instance class="exe.engine.lom.lomsubs.sourceValueSub">
         <dictionary>
          <string role="key" value="extensiontype_"></string>
          <none></none>
          <string role="key" value="string"></string>
          <list></list>
          <string role="key" value="uniqueElementName"></string>
          <string value="source"></string>
          <string role="key" value="valueOf_"></string>
          <string value="LOM-ESv1.0"></string>
         </dictionary>
        </instance>
        <string role="key" value="uniqueElementName"></string>
        <string value="aggregationLevel"></string>
        <string role="key" value="value"></string>
        <instance class="exe.engine.lom.lomsubs.aggregationLevelValueSub">
         <dictionary>
          <string role="key" value="extensiontype_"></string>
          <none></none>
          <string role="key" value="source"></string>
          <none></none>
          <string role="key" value="uniqueElementName"></string>
          <string value="value"></string>
          <string role="key" value="value"></string>
          <none></none>
          <string role="key" value="valueOf_"></string>
          <string value="2"></string>
         </dictionary>
        </instance>
       </dictionary>
      </instance>
      <string role="key" value="coverage"></string>
      <list></list>
      <string role="key" value="description"></string>
      <list>
       <instance class="exe.engine.lom.lomsubs.descriptionSub">
        <dictionary>
         <string role="key" value="extensiontype_"></string>
         <none></none>
         <string role="key" value="string"></string>
         <list>
          <instance class="exe.engine.lom.lomsubs.LangStringSub">
           <dictionary>
            <string role="key" value="language"></string>
            <string value="de"></string>
            <string role="key" value="valueOf_"></string>
            <string value="Das Skript zur Lehrveranstaltung Objektorientierte Programmierung im Studiengang Medieningenieur an der Fachhochschule Kiel"></string>
           </dictionary>
          </instance>
         </list>
        </dictionary>
       </instance>
      </list>
      <string role="key" value="identifier"></string>
      <list>
       <instance class="exe.engine.lom.lomsubs.identifierSub">
        <dictionary>
         <string role="key" value="catalog"></string>
         <instance class="exe.engine.lom.lomsubs.catalogSub">
          <dictionary>
           <string role="key" value="uniqueElementName"></string>
           <string value="catalog"></string>
           <string role="key" value="valueOf_"></string>
           <unicode value="My Catalog"></unicode>
          </dictionary>
         </instance>
         <string role="key" value="entry"></string>
         <instance class="exe.engine.lom.lomsubs.entrySub">
          <dictionary>
           <string role="key" value="uniqueElementName"></string>
           <string value="entry"></string>
           <string role="key" value="valueOf_"></string>
           <unicode value="4a7d755e-34a5-410a-a7d4-601881136623"></unicode>
          </dictionary>
         </instance>
        </dictionary>
       </instance>
      </list>
      <string role="key" value="keyword"></string>
      <list></list>
      <string role="key" value="language"></string>
      <list>
       <instance class="exe.engine.lom.lomsubs.LanguageIdSub">
        <dictionary>
         <string role="key" value="extensiontype_"></string>
         <none></none>
         <string role="key" value="valueOf_"></string>
         <string value="de"></string>
        </dictionary>
       </instance>
      </list>
      <string role="key" value="structure"></string>
      <none></none>
      <string role="key" value="title"></string>
      <instance class="exe.engine.lom.lomsubs.titleSub">
       <dictionary>
        <string role="key" value="extensiontype_"></string>
        <none></none>
        <string role="key" value="string"></string>
        <list>
         <instance class="exe.engine.lom.lomsubs.LangStringSub">
          <dictionary>
           <string role="key" value="language"></string>
           <string value="de"></string>
           <string role="key" value="valueOf_"></string>
           <string value="Objektorientierte Programmierung Skript"></string>
          </dictionary>
         </instance>
        </list>
        <string role="key" value="uniqueElementName"></string>
        <none></none>
       </dictionary>
      </instance>
      <string role="key" value="uniqueElementName"></string>
      <string value="general"></string>
     </dictionary>
    </instance>
    <string role="key" value="lifeCycle"></string>
    <instance class="exe.engine.lom.lomsubs.lifeCycleSub">
     <dictionary>
      <string role="key" value="contribute"></string>
      <list>
       <instance class="exe.engine.lom.lomsubs.contributeSub">
        <dictionary>
         <string role="key" value="date"></string>
         <instance class="exe.engine.lom.lomsubs.dateSub">
          <dictionary>
           <string role="key" value="dateTime"></string>
           <instance class="exe.engine.lom.lomsubs.DateTimeValueSub">
            <dictionary>
             <string role="key" value="uniqueElementName"></string>
             <string value="dateTime"></string>
             <string role="key" value="valueOf_"></string>
             <string value="2025-01-28T12:09:36.00+01:00"></string>
            </dictionary>
           </instance>
           <string role="key" value="description"></string>
           <instance class="exe.engine.lom.lomsubs.LanguageStringSub">
            <dictionary>
             <string role="key" value="extensiontype_"></string>
             <none></none>
             <string role="key" value="string"></string>
             <list>
              <instance class="exe.engine.lom.lomsubs.LangStringSub">
               <dictionary>
                <string role="key" value="language"></string>
                <string value="de"></string>
                <string role="key" value="valueOf_"></string>
                <string value="Erstellungsdatum des Metadatenschemas"></string>
               </dictionary>
              </instance>
             </list>
            </dictionary>
           </instance>
           <string role="key" value="extensiontype_"></string>
           <none></none>
           <string role="key" value="uniqueElementName"></string>
           <none></none>
           <string role="key" value="valueOf_"></string>
           <none></none>
          </dictionary>
         </instance>
         <string role="key" value="entity"></string>
         <list>
          <instance class="exe.engine.lom.lomsubs.entitySub">
           <dictionary>
            <string role="key" value="extensiontype_"></string>
            <none></none>
            <string role="key" value="valueOf_"></string>
            <string value="BEGIN:VCARD VERSION:3.0 FN:Jacqueline R\xc3\xa4hse EMAIL;TYPE=INTERNET: ORG: END:VCARD"></string>
           </dictionary>
          </instance>
         </list>
         <string role="key" value="role"></string>
         <instance class="exe.engine.lom.lomsubs.roleSub">
          <dictionary>
           <string role="key" value="extensiontype_"></string>
           <none></none>
           <string role="key" value="source"></string>
           <instance class="exe.engine.lom.lomsubs.sourceValueSub">
            <dictionary>
             <string role="key" value="extensiontype_"></string>
             <none></none>
             <string role="key" value="string"></string>
             <list></list>
             <string role="key" value="uniqueElementName"></string>
             <string value="source"></string>
             <string role="key" value="valueOf_"></string>
             <string value="LOM-ESv1.0"></string>
            </dictionary>
           </instance>
           <string role="key" value="uniqueElementName"></string>
           <string value="role"></string>
           <string role="key" value="value"></string>
           <instance class="exe.engine.lom.lomsubs.roleValueSub">
            <dictionary>
             <string role="key" value="extensiontype_"></string>
             <none></none>
             <string role="key" value="source"></string>
             <none></none>
             <string role="key" value="uniqueElementName"></string>
             <string value="value"></string>
             <string role="key" value="value"></string>
             <none></none>
             <string role="key" value="valueOf_"></string>
             <string value="author"></string>
            </dictionary>
           </instance>
          </dictionary>
         </instance>
        </dictionary>
       </instance>
      </list>
      <string role="key" value="status"></string>
      <none></none>
      <string role="key" value="uniqueElementName"></string>
      <none></none>
      <string role="key" value="version"></string>
      <none></none>
     </dictionary>
    </instance>
    <string role="key" value="metaMetadata"></string>
    <instance class="exe.engine.lom.lomsubs.metaMetadataSub">
     <dictionary>
      <string role="key" value="contribute"></string>
      <list>
       <instance class="exe.engine.lom.lomsubs.contributeMetaSub">
        <dictionary>
         <string role="key" value="date"></string>
         <instance class="exe.engine.lom.lomsubs.dateSub">
          <dictionary>
           <string role="key" value="dateTime"></string>
           <instance class="exe.engine.lom.lomsubs.DateTimeValueSub">
            <dictionary>
             <string role="key" value="uniqueElementName"></string>
             <string value="dateTime"></string>
             <string role="key" value="valueOf_"></string>
             <string value="2025-01-28T12:05:28.00+01:00"></string>
            </dictionary>
           </instance>
           <string role="key" value="description"></string>
           <instance class="exe.engine.lom.lomsubs.LanguageStringSub">
            <dictionary>
             <string role="key" value="extensiontype_"></string>
             <none></none>
             <string role="key" value="string"></string>
             <list>
              <instance class="exe.engine.lom.lomsubs.LangStringSub">
               <dictionary>
                <string role="key" value="language"></string>
                <string value="de"></string>
                <string role="key" value="valueOf_"></string>
                <string value="Erstellungsdatum des Metadatenschemas"></string>
               </dictionary>
              </instance>
             </list>
            </dictionary>
           </instance>
           <string role="key" value="extensiontype_"></string>
           <none></none>
           <string role="key" value="uniqueElementName"></string>
           <none></none>
           <string role="key" value="valueOf_"></string>
           <none></none>
          </dictionary>
         </instance>
         <string role="key" value="entity"></string>
         <list>
          <instance class="exe.engine.lom.lomsubs.entitySub">
           <dictionary>
            <string role="key" value="extensiontype_"></string>
            <none></none>
            <string role="key" value="valueOf_"></string>
            <string value="BEGIN:VCARD VERSION:3.0 FN:Jacqueline R\xc3\xa4hse EMAIL;TYPE=INTERNET: ORG: END:VCARD"></string>
           </dictionary>
          </instance>
         </list>
         <string role="key" value="role"></string>
         <instance class="exe.engine.lom.lomsubs.roleSub">
          <dictionary>
           <string role="key" value="extensiontype_"></string>
           <none></none>
           <string role="key" value="source"></string>
           <instance class="exe.engine.lom.lomsubs.sourceValueSub">
            <dictionary>
             <string role="key" value="extensiontype_"></string>
             <none></none>
             <string role="key" value="string"></string>
             <list></list>
             <string role="key" value="uniqueElementName"></string>
             <string value="source"></string>
             <string role="key" value="valueOf_"></string>
             <string value="LOM-ESv1.0"></string>
            </dictionary>
           </instance>
           <string role="key" value="uniqueElementName"></string>
           <string value="role"></string>
           <string role="key" value="value"></string>
           <instance class="exe.engine.lom.lomsubs.roleValueSub">
            <dictionary>
             <string role="key" value="extensiontype_"></string>
             <none></none>
             <string role="key" value="source"></string>
             <none></none>
             <string role="key" value="uniqueElementName"></string>
             <string value="value"></string>
             <string role="key" value="value"></string>
             <none></none>
             <string role="key" value="valueOf_"></string>
             <string value="creator"></string>
            </dictionary>
           </instance>
          </dictionary>
         </instance>
        </dictionary>
       </instance>
      </list>
      <string role="key" value="identifier"></string>
      <list></list>
      <string role="key" value="language"></string>
      <instance class="exe.engine.lom.lomsubs.LanguageIdSub">
       <dictionary>
        <string role="key" value="extensiontype_"></string>
        <none></none>
        <string role="key" value="valueOf_"></string>
        <string value="de"></string>
       </dictionary>
      </instance>
      <string role="key" value="metadataSchema"></string>
      <list>
       <instance class="exe.engine.lom.lomsubs.metadataSchemaSub">
        <dictionary>
         <string role="key" value="valueOf_"></string>
         <string value="LOM-ESv1.0"></string>
        </dictionary>
       </instance>
      </list>
      <string role="key" value="uniqueElementName"></string>
      <string value="metaMetadata"></string>
     </dictionary>
    </instance>
    <string role="key" value="relation"></string>
    <list></list>
    <string role="key" value="rights"></string>
    <instance class="exe.engine.lom.lomsubs.rightsSub">
     <dictionary>
      <string role="key" value="access"></string>
      <instance class="exe.engine.lom.lomsubs.accessSub">
       <dictionary>
        <string role="key" value="accessType"></string>
        <instance class="exe.engine.lom.lomsubs.accessTypeSub">
         <dictionary>
          <string role="key" value="extensiontype_"></string>
          <none></none>
          <string role="key" value="source"></string>
          <instance class="exe.engine.lom.lomsubs.sourceValueSub">
           <dictionary>
            <string role="key" value="extensiontype_"></string>
            <none></none>
            <string role="key" value="string"></string>
            <list></list>
            <string role="key" value="uniqueElementName"></string>
            <string value="source"></string>
            <string role="key" value="valueOf_"></string>
            <string value="LOM-ESv1.0"></string>
           </dictionary>
          </instance>
          <string role="key" value="uniqueElementName"></string>
          <string value="accessType"></string>
          <string role="key" value="value"></string>
          <instance class="exe.engine.lom.lomsubs.accessTypeValueSub">
           <dictionary>
            <string role="key" value="extensiontype_"></string>
            <none></none>
            <string role="key" value="source"></string>
            <none></none>
            <string role="key" value="uniqueElementName"></string>
            <string value="value"></string>
            <string role="key" value="value"></string>
            <none></none>
            <string role="key" value="valueOf_"></string>
            <string value="universal"></string>
           </dictionary>
          </instance>
         </dictionary>
        </instance>
        <string role="key" value="description"></string>
        <instance class="exe.engine.lom.lomsubs.LanguageStringSub">
         <dictionary>
          <string role="key" value="extensiontype_"></string>
          <none></none>
          <string role="key" value="string"></string>
          <list>
           <instance class="exe.engine.lom.lomsubs.LangStringSub">
            <dictionary>
             <string role="key" value="language"></string>
             <string value="en"></string>
             <string role="key" value="valueOf_"></string>
             <unicode value="Default"></unicode>
            </dictionary>
           </instance>
          </list>
         </dictionary>
        </instance>
        <string role="key" value="uniqueElementName"></string>
        <string value="access"></string>
       </dictionary>
      </instance>
      <string role="key" value="copyrightAndOtherRestrictions"></string>
      <instance class="exe.engine.lom.lomsubs.copyrightAndOtherRestrictionsSub">
       <dictionary>
        <string role="key" value="extensiontype_"></string>
        <none></none>
        <string role="key" value="source"></string>
        <instance class="exe.engine.lom.lomsubs.sourceValueSub">
         <dictionary>
          <string role="key" value="extensiontype_"></string>
          <none></none>
          <string role="key" value="string"></string>
          <list></list>
          <string role="key" value="uniqueElementName"></string>
          <string value="source"></string>
          <string role="key" value="valueOf_"></string>
          <string value="LOM-ESv1.0"></string>
         </dictionary>
        </instance>
        <string role="key" value="uniqueElementName"></string>
        <string value="copyrightAndOtherRestrictions"></string>
        <string role="key" value="value"></string>
        <instance class="exe.engine.lom.lomsubs.copyrightAndOtherRestrictionsValueSub">
         <dictionary>
          <string role="key" value="extensiontype_"></string>
          <none></none>
          <string role="key" value="source"></string>
          <none></none>
          <string role="key" value="uniqueElementName"></string>
          <string value="value"></string>
          <string role="key" value="value"></string>
          <none></none>
          <string role="key" value="valueOf_"></string>
          <string value="creative commons: attribution - share alike"></string>
         </dictionary>
        </instance>
       </dictionary>
      </instance>
      <string role="key" value="cost"></string>
      <none></none>
      <string role="key" value="description"></string>
      <none></none>
      <string role="key" value="uniqueElementName"></string>
      <string value="rights"></string>
     </dictionary>
    </instance>
    <string role="key" value="technical"></string>
    <none></none>
   </dictionary>
  </instance>
  <string role="key" value="mxmlforcemediaonly"></string>
  <bool value="0"></bool>
  <string role="key" value="mxmlheight"></string>
  <string value=""></string>
  <string role="key" value="mxmlprofilelist"></string>
  <string value=""></string>
  <string role="key" value="mxmlwidth"></string>
  <string value=""></string>
  <string role="key" value="release"></string>
  <string value="2.9"></string>
  <string role="key" value="resources"></string>
  <dictionary></dictionary>
  <string role="key" value="root"></string>
  <reference key="5"></reference>
  <string role="key" value="scolinks"></string>
  <bool value="0"></bool>
  <string role="key" value="scowsinglepage"></string>
  <bool value="0"></bool>
  <string role="key" value="scowwebsite"></string>
  <bool value="0"></bool>
  <string role="key" value="style"></string>
  <unicode value="fh_kiel"></unicode>
  <string role="key" value="sugaractivityname"></string>
  <string value=""></string>
  <string role="key" value="sugarservicename"></string>
  <string value=""></string>
  <string role="key" value="tempFile"></string>
  <bool value="0"></bool>
 </dictionary>
</instance>