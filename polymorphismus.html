<!doctype html>
<html lang="de">
<head>
<link rel="stylesheet" type="text/css" href="base.css" />
<link rel="stylesheet" type="text/css" href="exe_effects.css" />
<link rel="stylesheet" type="text/css" href="exe_highlighter.css" />
<link rel="stylesheet" type="text/css" href="content.css" />
<link rel="stylesheet" type="text/css" href="nav.css" />
<meta http-equiv="content-type" content="text/html;  charset=utf-8" />
<title>Polymorphismus | Objektorientierte Programmierung Skript </title>
<link rel="shortcut icon" href="favicon.ico" type="image/x-icon" />
<meta name="author" content="Jacqueline Rähse" />
<link rel="license" type="text/html" href="http://creativecommons.org/licenses/by-sa/4.0/" />
<meta name="generator" content="eXeLearning 2.9 - exelearning.net" />
<!--[if lt IE 9]><script type="text/javascript" src="exe_html5.js"></script><![endif]-->
<script type="text/javascript" src="exe_jquery.js"></script>
<script type="text/javascript" src="exe_effects.js"></script>
<script type="text/javascript" src="exe_highlighter.js"></script>
<script type="text/javascript" src="common_i18n.js"></script>
<script type="text/javascript" src="common.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
    </head>
<body class="exe-web-site" id="exe-node-4"><script type="text/javascript">document.body.className+=" js"</script>
<div id="content">
<p id="skipNav"><a href="#main" class="sr-av">Navigation überspringen</a></p>
<header id="header" ><div id="headerContent">Objektorientierte Programmierung Skript</div></header>
<nav id="siteNav">
<ul>
   <li><a href="index.html" class="daddy main-node">Objektorientierte Programmierung</a></li>
   <li><a href="java.html" class="daddy">Java</a>
   <ul class="other-section">
      <li><a href="erste_schritte_in_java.html" class="no-ch">Erste Schritte in Java</a></li>
      <li><a href="grundlagen.html" class="no-ch">Grundlagen</a></li>
      <li><a href="ausnahmebehandlung.html" class="no-ch">Ausnahmebehandlung</a></li>
      <li><a href="collections_und_lambda_ausdrcke.html" class="no-ch">Collections und Lambda Ausdrücke</a></li>
   </ul>
   </li>
   <li><a href="klassen_und_objekte.html" class="daddy">Klassen und Objekte</a>
   <ul class="other-section">
      <li><a href="packages_und_api.html" class="no-ch">Packages und API</a></li>
      <li><a href="processing_in_anderen_klassen_nutzen.html" class="no-ch">Processing in anderen Klassen nutzen</a></li>
   </ul>
   </li>
   <li><a href="konzeption_und_dokumentation.html" class="no-ch">Konzeption und Dokumentation</a></li>
   <li><a href="kapselung.html" class="no-ch">Kapselung</a></li>
   <li><a href="vererbung.html" class="no-ch">Vererbung</a></li>
   <li><a href="abstraktion.html" class="no-ch">Abstraktion</a></li>
   <li id="active"><a href="polymorphismus.html" class="active no-ch">Polymorphismus</a></li>
   <li><a href="design_patterns.html" class="no-ch">Design Patterns</a></li>
</ul>
</nav>
<div id='topPagination'>
<nav class="pagination noprt">
<a href="abstraktion.html" class="prev"><span><span>&laquo; </span>Vorheriges</span></a> <span class="sep">| </span><a href="design_patterns.html" class="next"><span>Nächste<span> &raquo;</span></span></a>
</nav>
</div>
<div id="main-wrapper">
<section id="main">
<header id="nodeDecoration"><h1 id="nodeTitle">Polymorphismus</h1></header>
<article class="iDevice_wrapper textIdevice" id="id4">
<div class="iDevice emphasis0" >
<div id="ta4_131_2" class="block iDevice_content">
<div class="exe-text"><h1>Einführung</h1>
<p>Die letzte Säule der Objektorientierten Programmierung ist der Polymorphismus (oder auch Polymorphie). Polymorphismus bedeutet so viel wie "Vielgestaltigkeit" - also, dass ein und dieselbe Sache, viele unterschiedliche Gestalten annehmen kann. Dabei kann es sich um Objekte oder auch um Verhalten handeln. Stell dir eine Reihe von Personen vor, die arbeiten gehen. Bei jeder dieser Personen wird "arbeiten gehen" unterschiedlich aussehen, da sie unterschiedliche Berufe ausführen - dasselbe "allgemeine" Verhalten nimmt viele verschiedene Gestalten an.</p>
<p>In unserem Tier Beispiel aus den vorherigen Kapiteln ist das Prinzip des Polymorphismus ebenfalls gut zu erkennen: Ein Tier (bzw. ein Objekt der Klasse Tier) kann verschiedene Gestalten annehmen, nämlich Säugetier, Fisch, Hund, Wal, etc., obwohl alles Tiere sind. Und auch ihr Verhalten kann unterschiedliche Formen annehmen: jedes Tier macht ein anderes Geräusch, obwohl der Verhalten geraeuschMachen() dasselbe ist.</p>
<p>Polymorphismus ist eine der zentralen Säulen der objektorientierten Programmierung. Wir sind dem Polymorphismus an einigen Stellen bereits begegnet.</p>
<p>In diesem Kapitel lernst du:</p>
<ul>
<li>Was Polymorphismus ist</li>
<li>Die Unterschiede zwischen statischem und dynamischen Polymorphismus</li>
<li>Die konkrete Anwendung von Polymorphismus im Code</li>
<li>Die Vor- und Nachteile von Polymorphismus</li>
</ul>
<h1>Grundlagen des Polymorphismus</h1>
<p>Polymorphismus ist eines der grundlegenden Konzepte der objektorientierten Programmierung in Java. Der Begriff leitet sich vom griechischen "poly" (viele) und "morph" (Form) ab und bedeutet "Vielgestaltigkeit". In der Java-Programmierung bezieht sich Polymorphismus auf die Fähigkeit von Objekten, in verschiedenen Formen aufzutreten und auf unterschiedliche Weise zu reagieren. Dabei hat Polymorphismus in Java drei Hauptaspekte:</p>
<ul>
<li><strong>Behandlung von Objekten als Instanzen ihrer Oberklasse</strong>:<br />Polymorphismus erlaubt es, Objekte verschiedener Unterklassen als Instanzen ihrer gemeinsamen Oberklasse zu behandeln3 Dies erhöht die Flexibilität und Wiederverwendbarkeit des Codes.</li>
<li><strong>Überschreiben von Methoden</strong>:<br />Eine zentrale Technik des Polymorphismus ist das Überschreiben (@Override) von Methoden. Unterklassen können Methoden ihrer Oberklassen neu implementieren, um spezifisches Verhalten zu definieren.</li>
<li><strong>Dynamische Bindung</strong>:<br />Polymorphismus ermöglicht es, dass der konkrete Typ eines Objekts erst zur Laufzeit bestimmt wird. Dies wird als dynamische Bindung bezeichnet. Wenn eine Methode aufgerufen wird, entscheidet die Java Virtual Machine (JVM) zur Laufzeit, welche spezifische Implementierung der Methode ausgeführt werden soll, basierend auf dem <em>tatsächlichen</em> Objekttyp.</li>
</ul>
<p>Diese 3 Aspekte lassen sich sehr gut an unserem Tier Beispiel veranschaulichen:</p>
<div class="highlighted-code language-java line-numbers hightlight-24and33and37">
<div>
<pre><code>abstract class Tier {
    protected String name;

    public Tier(String name) {
        this.name = name;
    }

    public abstract void geraeuschMachen();
}

abstract class Saeugetier extends Tier {
    public Saeugetier(String name) {
        super(name);
    }
}

class Hund extends Saeugetier {
    public Hund(String name) {
        super(name);
    }

     // Überschreiben von Methoden mit eigener Implementierung
    @Override
    public void geraeuschMachen() {
        System.out.println(name + " bellt: Wuff!");
    }
}

public class Main {
    public static void main(String[] args) {
         // Behandlung von Objekten als Instanzen ihrer Oberklasse:
         // Ein Objekt vom Typ Hund kann als Objekt vom Typ Tier behandelt werden
        Tier meinTier = new Hund("Bello");

        // Dynamische Bindung: Hier wird zu Laufzeit entschieden, welche 
        // Implementierung der Methode geraeuschMachen genau verwendet wird.
        meinTier.geraeuschMachen(); // Ausgabe: Bello bellt: Wuff!
    }
}</code></pre>
</div>
</div>
<h1>Arten des Polymorphismus in Java</h1>
<p>Polymorphismus in Java lässt sich in zwei Arten unterteilen: statischer und dynamischer Polymorphismus.</p>
<h2>Statischer Polymorphismus</h2>
<p>Statischer Polymorphismus nutzt <strong>Methodenüberladung,</strong> um eine Methode mit unterschiedlichen Implementierungen zu haben. Aus diesem Grund wird er auch als statisch bezeichnet, da im Code bereits zum Zeitpunkt der Kompilierung festgelegt ist, welche Methode angewendet wird. Die Entscheidung, welche Methode zur Compile-Zeit aufgerufen wird, basiert auf der Signatur der Methode.</p>
<p>Zum Beispiel könnten wir in der Tier-Klasse die Methode <span style="font-family: andale mono, monospace;">geraeuschMachen()</span> überladen, indem wir eine Version hinzufügen, bei der man im Parameter angeben kann, wie oft ein Geräusch gemacht werden soll.</p>
<div class="highlighted-code language-java line-numbers hightlight-9and29and45">
<div>
<pre><code>abstract class Tier {
    protected String name;

    public Tier(String name) {
        this.name = name;
    }

    public abstract void geraeuschMachen();
    public abstract void geraeuschMachen(int Anzahl);
}

abstract class Saeugetier extends Tier {
    public Saeugetier(String name) {
        super(name);
    }
}

class Hund extends Saeugetier {
    public Hund(String name) {
        super(name);
    }

    @Override
    public void geraeuschMachen() {
        System.out.println(name + " bellt: Wuff!");
    }
    
    @Override
    public void geraeuschMachen(int Anzahl) {
        String s = name + " bellt: ";

        for (int i = 0; i &lt; Anzahl; i++) {
            s += " Wuff!";
        }

        System.out.println(s);
    }
}

public class Main {
    public static void main(String[] args) {

        Tier meinTier = new Hund("Bello");
        meinTier.geraeuschMachen(); // Ausgabe: Bello bellt: Wuff!
        meinTier.geraeuschMachen(3); // Ausgabe: Bello bellt: Wuff! Wuff! Wuff!
    }
}</code></pre>
</div>
</div>
<p>In Zeile 45 ist bereits zur Compile-Zeit eindeutig festgelegt, welche Implementierung der Methode umgesetzt wird durch die eindeutige Methodensignatur.</p>
<h2>Dynamischer Polymorphismus</h2>
<p>Dynamischer Polymorphismus nutzt Methodenüberschreibung und dynamische Bindung. Dabei wird erst zur Laufzeit entschieden, basierend auf dem konkreten Objekttyp, welche Implementierung ausgeführt wird. Aus diesem Grund wird er als dynamisch bezeichnet, da erst zur Laufzeit klar wird, welchen Typ das Objekt hat und welche Implementierung deswegen Anwendung findet.</p>
<p>Methodenüberschreibung und dynamische Bindung wurden im ersten Beispiel in diesem Kapitel veranschaulicht. Zur Veranschaulichung der dynamischen Bindung ergänzen wir dieses Beispiel noch um die Klasse <span style="font-family: andale mono, monospace;">Katze</span>:</p>
<div class="highlighted-code language-java line-numbers hightlight-44and45">
<div>
<pre><code>abstract class Tier {
    protected String name;

    public Tier(String name) {
        this.name = name;
    }

    public abstract void geraeuschMachen();
}

abstract class Saeugetier extends Tier {
    public Saeugetier(String name) {
        super(name);
    }
}

class Hund extends Saeugetier {
    public Hund(String name) {
        super(name);
    }

    @Override
    public void geraeuschMachen() {
        System.out.println(name + " bellt: Wuff!");
    }
}

class Katze extends Saeugetier {
    public Katze(String name) {
        super(name);
    }

    @Override
    public void geraeuschMachen() {
        System.out.println(name + " miaut: Miau!");
    }
}

public class Main {
    public static void main(String[] args) {

        Tier meinHund = new Hund("Bello");
        Tier meineKatze = new Katze("Minka");
        meinHund.geraeuschMachen(); // Ausgabe: Bello bellt: Wuff!
        meineKatze.geraeuschMachen(); // Ausgabe: Minka miaut: Miau!
    }
}</code></pre>
</div>
</div>
<h1>Polymorphismus mit Interfaces</h1>
<p>Das Prinzip der dynamischen Bindung und der Behandlung von Objekten als Instanzen ihrer Oberklasse funktioniert auch in Bezug auf Interfaces. Konkret bedeutet das, ich kann ein Objekt auch über den Typ des <em>Interface</em> ansprechen. Schauen wir uns das einmal anhand des Beispiels aus dem Kapitel <a href="abstraktion.html" target="_blank" title="Zum Kapitel Abstraktion" rel="noopener">Abstraktion</a> an, in dem wir die Interfaces <span style="font-family: andale mono, monospace;">Drawable</span> und <span style="font-family: andale mono, monospace;">Movable</span> erstellt haben, welche von den Klassen <span style="font-family: andale mono, monospace;">Player</span> und <span style="font-family: andale mono, monospace;">Wall</span> implementiert wurden. Wir erweitern das Beispiel, indem wir sie in mit Processing in Java kombinieren, damit wir einen draw-Loop haben.</p>
<p>Dynamischer Polymorphismus ermöglicht mir nun folgendes: </p>
<ul>
<li>In der <span style="font-family: andale mono, monospace;">Window</span> Klasse deklariere ich zunächst die Variablen <span style="font-family: andale mono, monospace;">player</span> und <span style="font-family: andale mono, monospace;">wall</span> und einen Array vom Typ <span style="font-family: andale mono, monospace;">Drawable</span> mit der Länge 2. Du siehst: Ich kann auch ein Interface als Datentyp verwenden.</li>
<li>In <span style="font-family: andale mono, monospace;">settings()</span> initialisiere ich nun <span style="font-family: andale mono, monospace;">player</span> und <span style="font-family: andale mono, monospace;">wall</span> und speichere diese in meinem <span style="font-family: andale mono, monospace;">drawables</span> Array</li>
<li>Nun kann ich in <span style="font-family: andale mono, monospace;">draw()</span> durch meinen <span style="font-family: andale mono, monospace;">drawbles</span> Array iterieren und diese zeichnen über die <span style="font-family: andale mono, monospace;">draw()</span> Methode aus dem Interface. Das geht, weil durch den Typ des Interfaces festgelegt ist, dass alle Elemente in einem Array vom Typ <span style="font-family: andale mono, monospace;">Drawable</span> eine <span style="font-family: andale mono, monospace;">draw()</span> Methode besitzen. Allerdings kann jedes Element diese <span style="font-family: andale mono, monospace;">draw()</span> Methode unterschiedlich umsetzen - das <span style="font-family: andale mono, monospace;">player</span>-Objekt setzt die Methode anders um, als das <span style="font-family: andale mono, monospace;">wall-</span>Objekt.  </li>
</ul>
<div class="highlighted-code language-java line-numbers">
<div>
<pre><code>import processing.core.PApplet;

public class Window extends PApplet {

    Player player;
    Wall wall;
    Drawable[] drawables = new Drawable[2];

    @Override
    public void settings() {
        size( 400, 400);

        player = new Player(100, 100);
        wall = new Wall(200, 200);

        // Hinzufügen von player und wall zum drawables Array
        drawables[0] = player;
        drawables[1] = wall;
        
    }

    @Override
    public void draw() {
        background(60);

        // Zeichnen aller Elemente im drawbles Array
        for(Drawable drawable : drawables) {
            drawable.draw();
        }

    }
}

interface Movable {
    void move();
}

interface Drawable {
    void draw();
}

class Player implements Movable, Drawable {

    private float x,y;

    public Player(float  x, float y) {
        this.x = x;
        this.y = y;
    }

    @Override
    public void move() {
        System.out.println("Steuerung per Pfeiltasten");
    }

    @Override
    public void draw() {
        System.out.println("Zeichne Spieler bei x: " + x + " y: " + y);

    }
}

class Wall implements Drawable {

    private float x,y;

    public Wall(float x, float y) {
        this.x = x;
        this.y = y;
    }

    @Override
    public void draw() {
        System.out.println("Zeichne Wand bei x: " + x + " y: " + y);
    }
}
</code></pre>
</div>
</div>
<h1>Vergleich zu Vererbung und Methodenüberladung</h1>
<p>Polymorphismus basiert wesentlich auf den behandelten Prinzipien der <a href="vererbung.html">Vererbung</a>. Während Vererbung es erlaubt, allgemeine Eigenschaften und Methoden an Subklassen zu übertragen, geht es beim Polymorphismus darum, dass diese geerbten Methoden in den Subklassen auf unterschiedliche Weise umgesetzt werden können.</p>
<ul>
<li><strong>Vererbung</strong> liefert den Bauplan und die Übernahme von Eigenschaften.</li>
<li><strong>Methodenüberladung</strong> (statischer Polymorphismus) ermöglicht es, dass innerhalb derselben Klasse mehrere Methoden mit demselben Namen, aber unterschiedlichen Parametern existieren.</li>
<li><strong>Methodenüberschreibung</strong> (dynamischer Polymorphismus) sorgt dafür, dass in einer Vererbungshierarchie eine Methode in der Subklasse neu definiert werden kann.<br />Die Kombination dieser Konzepte ermöglicht es, Programme zu schreiben, bei denen durch einheitliche Schnittstellen unterschiedliche Implementierungen zur Laufzeit gewählt werden – ein entscheidender Vorteil bei der Erweiterung und Pflege von Software.</li>
</ul>
<h1>Abschluss</h1>
<div class="exe-fx exe-accordion">
<h2>Aufgaben</h2>
<ul>
<li><strong>Aufgabe 1</strong>: Tierhierarchie erweitern<br />Erweitere das in Kapitel 4 eingeführte Beispiel. Erstelle zusätzlich zur Klasse Hund und Katze eine weitere Subklasse Vogel, die die Methode geraeuschMachen() überschreibt (z. B. mit der Ausgabe „zwitschert: Zirp,zirp“).<br />Erstelle in einer Main-Methode ein Array vom Typ Tier, das Objekte aller drei Klassen enthält, und rufe für jedes Objekt die Methode geraeuschMachen() auf.</li>
<li><strong>Aufgabe 2</strong>: Grafische Anwendung in Processing<br />Entwickle eine einfache Klassenhierarchie für grafische Formen. Ergänze das Beispiel von Circle und Rectangle um eine weitere Form (z. B. Triangle) und implementiere eine polymorphe draw()-Methode für alle Formen.<br />Schreibe eine Main-Methode, in der ein Array verschiedener Formen durchlaufen und jede Form gezeichnet wird.</li>
</ul>
<h2>Fragen</h2>
<ol>
<li>Was versteht man unter dynamischer Bindung im Kontext des Polymorphismus?</li>
<li>Worin unterscheiden sich statischer und dynamischer Polymorphismus?</li>
<li>Welche Vorteile bietet der Einsatz von Polymorphismus in der Softwareentwicklung?</li>
<li>Warum ist es sinnvoll, in grafischen Anwendungen (wie in Processing) polymorphe Methoden einzusetzen?</li>
</ol>
<h2>Zusammenfassung</h2>
<div>
<div>
<div>
<div>
<ul>
<li>
<div>Polymorphismus bedeutet "Vielgestaltigkeit" und ermöglicht Objekten, in verschiedenen Formen aufzutreten und unterschiedlich zu reagieren</div>
</li>
<li>Hauptaspekte von Polymorphismus:
<ul>
<li><strong>Behandlung von Objekten als Instanzen ihrer Oberklasse</strong>: Ein Hund-Objekt kann als Tier-Objekt behandelt werden</li>
<li>
<div><strong>Überschreiben von Methoden</strong>: Tier-Objekte können unterschiedliche Geräusche machen</div>
</li>
<li>
<div><strong>Dynamische Bindung:</strong> Erst zur Laufzeit wird bestimmt, ob es sich um ein Katze-Objekt oder ein Hund-Objekt handelt</div>
</li>
</ul>
</li>
<li>Arten des Polymorphismus:
<ul>
<li><strong>Statischer Polymorphismus</strong>
<ul>
<li>Nutzt Methodenüberladung</li>
<li>
<div>Entscheidung über aufzurufende Methode erfolgt zur Kompilierzeit</div>
</li>
</ul>
</li>
<li>
<div><strong>Dynamischer Polymorphismus</strong></div>
<ul>
<li>
<div>Nutzt Methodenüberschreibung und dynamische Bindung</div>
</li>
<li>
<div>Entscheidung über aufzurufende Methode basiert auf konkretem Objekttyp zur Laufzeit</div>
</li>
</ul>
</li>
</ul>
</li>
<li>Objekte können über Interface-Typen angesprochen werden</li>
<li>
<div><strong>Vorteile:</strong> Erhöhte Flexibilität, verbesserte Wiederverwendbarkeit, Vereinfachte Wartbarkeit, Verbesserte Übersichtlichkeit, Erhöhte Modularität, Vereinfachte Erweiterbarkeit</div>
</li>
<li>
<div><strong>Nachteile:</strong> Leistungseinbußen, erhöhte Komplexität, Implementierungsherausforderungen, Debugging-Schwierigkeiten, Einschränkungen bei Compiler-Optimierungen</div>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<p></p>
<p></p></div>
</div>
</div>
</article>
<div id="packageLicense" class="cc cc-by-sa">
<p><span>Lizenziert unter  </span> <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution Share Alike License 4.0</a></p>
</div>
</section>
</div>
<div id='bottomPagination'>
<nav class="pagination noprt">
<a href="abstraktion.html" class="prev"><span><span>&laquo; </span>Vorheriges</span></a> <span class="sep">| </span><a href="design_patterns.html" class="next"><span>Nächste<span> &raquo;</span></span></a>
</nav>
</div>
</div>
<p id="made-with-eXe"><a href="https://exelearning.net/" target="_blank" rel="noopener"><span>Made with eXeLearning<span> (New Window)</span></span></a></p><script type="text/javascript" src="_style_js.js"></script></body></html>