<!doctype html>
<html lang="de">
<head>
<link rel="stylesheet" type="text/css" href="base.css" />
<link rel="stylesheet" type="text/css" href="exe_highlighter.css" />
<link rel="stylesheet" type="text/css" href="content.css" />
<link rel="stylesheet" type="text/css" href="nav.css" />
<meta http-equiv="content-type" content="text/html;  charset=utf-8" />
<title>Programmierprinzipien | Objektorientierte Programmierung Skript </title>
<link rel="shortcut icon" href="favicon.ico" type="image/x-icon" />
<meta name="author" content="Jacqueline Rähse" />
<link rel="license" type="text/html" href="http://creativecommons.org/licenses/by-sa/4.0/" />
<meta name="generator" content="eXeLearning 2.9 - exelearning.net" />
<!--[if lt IE 9]><script type="text/javascript" src="exe_html5.js"></script><![endif]-->
<script type="text/javascript" src="exe_jquery.js"></script>
<script type="text/javascript" src="exe_highlighter.js"></script>
<script type="text/javascript" src="common_i18n.js"></script>
<script type="text/javascript" src="common.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
    </head>
<body class="exe-web-site" id="exe-node-12"><script type="text/javascript">document.body.className+=" js"</script>
<div id="content">
<p id="skipNav"><a href="#main" class="sr-av">Navigation überspringen</a></p>
<header id="header" ><div id="headerContent">Objektorientierte Programmierung Skript</div></header>
<nav id="siteNav">
<ul>
   <li><a href="index.html" class="daddy main-node">Objektorientierte Programmierung</a></li>
   <li><a href="einfhrung_in_die_objekorientierte_programmierung.html" class="no-ch">Einführung in die objekorientierte Programmierung</a></li>
   <li><a href="grundlagen_der_javaprogrammierung.html" class="daddy">Grundlagen der Java-Programmierung</a>
   <ul class="other-section">
      <li><a href="ausnahmebehandlung.html" class="no-ch">Ausnahmebehandlung</a></li>
      <li><a href="collections_framework.html" class="no-ch">Collections Framework</a></li>
   </ul>
   </li>
   <li><a href="klassen_und_objekte.html" class="no-ch">Klassen und Objekte</a></li>
   <li><a href="vererbung.html" class="no-ch">Vererbung</a></li>
   <li><a href="abstrakte_klassen_und_interfaces.html" class="no-ch">Abstrakte Klassen und Interfaces</a></li>
   <li><a href="polymorphismus.html" class="no-ch">Polymorphismus</a></li>
   <li><a href="design_patterns.html" class="no-ch">Design Patterns</a></li>
   <li id="active"><a href="programmierprinzipien.html" class="active no-ch">Programmierprinzipien</a></li>
</ul>
</nav>
<div id='topPagination'>
<nav class="pagination noprt">
<a href="design_patterns.html" class="prev"><span><span>&laquo; </span>Vorheriges</span></a>
</nav>
</div>
<div id="main-wrapper">
<section id="main">
<header id="nodeDecoration"><h1 id="nodeTitle">Programmierprinzipien</h1></header>
<article class="iDevice_wrapper textIdevice" id="id18">
<div class="iDevice emphasis0" >
<div id="ta18_144_2" class="block iDevice_content">
<div class="exe-text"><p>.</p>
<h2>1. Einleitung</h2>
<p>Hier folgt das Kapitel Programmierprinzipien – ein umfassender Leitfaden, der zeigt, wie Versionskontrolle und Dokumentation als Grundlage für erfolgreiche Teamprojekte dienen. Wir beleuchten dabei detailliert, wie Git – sowohl über die Kommandozeile als auch direkt in der IntelliJ IDEA – eingesetzt wird, um mittels grundlegender Befehle wie git init, git add, git commit, git push, git pull und git merge den Code in einem kollaborativen Umfeld zu verwalten. Anschließend erklären wir, welche Rolle eine saubere Dokumentation spielt, wie UML-Diagramme und Javadoc-Beispiele konkret umgesetzt werden und welche Folgen unzureichende Dokumentation (etwa ein niedriger Truck-Factor) haben kann</p>
<p>In interdisziplinären Projekten – etwa im Studiengang Medieningenieur – ist es entscheidend, dass mehrere Teammitglieder gleichzeitig an einer Codebasis arbeiten können. Eine strukturierte Versionskontrolle mittels Git verhindert, dass einzelne Änderungen verloren gehen, und ermöglicht es, den Projektfortschritt jederzeit nachvollziehen zu können. Gleichzeitig stellt eine aussagekräftige Dokumentation sicher, dass neu eingestellte Teammitglieder oder Kollegen schnell den Überblick über die Codearchitektur gewinnen. In diesem Kapitel erfährst du, wie Du beides – Versionskontrolle und Dokumentation – im Rahmen eines größeren Softwareprojekts effizient umsetzt.</p>
<h2>2. Versionskontrolle und Zusammenarbeit mit Git</h2>
<h3>2.1 Grundlagen von Git</h3>
<p>Git ist ein verteiltes Versionskontrollsystem, das den gesamten Projektverlauf als eine Reihe von Snapshots (Commits) speichert. Dabei wird unterschieden in:</p>
<ul>
<li>Arbeitsverzeichnis (Working Directory): Hier bearbeitest du deine Quellcodedateien.</li>
<li>Staging Area (Index): In diesem Zwischenspeicher werden selektiv Dateien markiert, die in den nächsten Commit aufgenommen werden sollen.</li>
<li>Repository: Hier werden alle erstellten Commits dauerhaft gespeichert.</li>
</ul>
<p>Git speichert Änderungen durch den Einsatz von sogenannten Snapshots. Mit der Trennung in Staging und Commit-Phase hast du die volle Kontrolle darüber, welche Änderungen du dokumentieren möchtest.</p>
<h3>2.2 Detaillierte Schritt‑für‑Schritt-Anleitungen: Kommandozeile</h3>
<h4>2.2.1 Git am Anfang: Repository initialisieren</h4>
<ol>
<li>Git installieren:<br />Lade Git von der offiziellen Website (https://git-scm.com) herunter und installiere es.</li>
<li>Arbeitsverzeichnis anlegen und Repository initialisieren:<br />Öffne die Kommandozeile, navigiere in das Verzeichnis deines Projekts und führe folgenden Befehl aus:<br />
<div class="highlighted-code code-style-2 language-markup">
<div>
<pre><code>git init</code></pre>
</div>
</div>
Dadurch wird ein neues Git-Repository (ein versteckter Ordner namens .git) im Projektverzeichnis erstellt.</li>
</ol>
<h3>2.2.2 Dateien zum Staging-Bereich hinzufügen</h3>
<p>Bevor du einen Snapshot machst, musst du die Änderungen „stagen“. Dies geschieht mit:</p>
<div class="highlighted-code code-style-2 language-markup">
<div>
<pre><code>git add &lt;Dateiname&gt;</code></pre>
</div>
</div>
<p>oder, um <em>alle</em> geänderten Dateien hinzuzufügen:</p>
<div class="highlighted-code code-style-2 language-markup">
<div>
<pre><code>git add .</code></pre>
</div>
</div>
<p>Hierbei werden die Änderungen im Staging-Bereich (Index) zusammengetragen.</p>
<h4>2.2.3 Einen Commit erstellen</h4>
<p>Nachdem die gewünschten Dateien im Staging-Bereich liegen, erstellst du einen Commit:</p>
<div class="highlighted-code code-style-2 language-markup">
<div>
<pre><code> git commit -m "Erste Commit-Nachricht: Projekt initialisiert"</code></pre>
</div>
</div>
<p>Der Commit speichert einen Snapshot der aktuell gestagten Dateien in deiner lokalen Historie. Die Commit-Nachricht sollte kurz und prägnant beschreiben, was geändert wurde.</p>
<h4>2.2.4 Branches verwalten</h4>
<p>Um parallel an neuen Features zu arbeiten, werden Branches genutzt:</p>
<div class="highlighted-code code-style-2 language-markup">
<div>
<pre><code>git branch feature/neues-feature
git checkout feature/neues-feature</code></pre>
</div>
</div>
<p>Alternativ:</p>
<div class="highlighted-code code-style-2 language-markup">
<div>
<pre><code>git checkout -b feature/neues-feature</code></pre>
</div>
</div>
<p>Dadurch wird ein neuer Branch erstellt und direkt gewechselt.</p>
<h4>2.2.5 Änderungen integrieren: Merge</h4>
<p>Wenn du mit der Arbeit in einem Feature-Branch fertig bist, möchtest du die Änderungen in den Hauptbranch (z. B. main oder master) integrieren:</p>
<ol>
<li>Wechsle in den Hauptbranch:<br />
<div class="highlighted-code code-style-2 language-markup">
<div>
<pre><code>git checkout main</code></pre>
</div>
</div>
</li>
<li>Führe einen Merge durch:<br />
<div class="highlighted-code code-style-2 language-markup">
<div>
<pre><code>git merge feature/neues-feature</code></pre>
</div>
</div>
</li>
</ol>
<p>Bei einfachen Änderungen werden Merge-Konflikte selten; sollte es jedoch zu Konflikten kommen, zeigt Git an, in welchen Dateien Konflikte vorliegen. In solchen Fällen bearbeitest du die entsprechenden Dateien manuell, markierst die Konfliktbereiche (Git fügt spezielle Markierungen ein) und führst anschließend einen weiteren Commit durch.</p>
<h4>2.2.6 Remote Repositories: Origin und GitLab</h4>
<p>Remote Repositories ermöglichen es, dass dein lokales Repository mit einem zentralen Server (z. B. GitLab) synchronisiert wird.</p>
<ul>
<li>Remote hinzufügen:<br />Um ein Remote-Repository hinzuzufügen, verwende:<br />
<div class="highlighted-code code-style-2 language-markup">
<div>
<pre><code>git remote add origin https://gitlab.com/USERNAME/REPOSITORY.git</code></pre>
</div>
</div>
Dabei bezeichnet „origin“ den Standardnamen des Remote-Repositories.</li>
<li>Änderungen pushen:<br />Nach dem Hinzufügen des Remotes werden die lokalen Commits ins Remote-Repository übertragen:<br />
<div class="highlighted-code code-style-2 language-markup">
<div>
<pre><code>git push -u origin main</code></pre>
</div>
</div>
Das -u-Flag setzt den Upstream für den aktuellen Branch, sodass spätere Push- und Pull-Befehle einfacher auszuführen sind.</li>
<li>Änderungen abrufen:<br />Um die neuesten Änderungen aus dem Remote-Repository zu erhalten, benutze:<br />
<div class="highlighted-code code-style-2 language-markup">
<div>
<pre><code>git pull</code></pre>
</div>
</div>
Dieser Befehl führt intern ein git fetch gefolgt von einem git merge durch.</li>
</ul>
<p>Weitere Remote-Befehle:</p>
<ul>
<li>git status: Zeigt den aktuellen Zustand deines Arbeitsverzeichnisses, den Staging-Bereich und die Verbindung zu Remotes an.</li>
<li>git log: Zeigt die Commit-Historie (mit Hashes, Autor und Nachrichten).</li>
<li>git diff: Zeigt Unterschiede zwischen Dateien—entweder vor oder nach dem Stagen.</li>
</ul>
<h3>2.3 Git in der IntelliJ IDEA</h3>
<p>IntelliJ IDEA bietet eine sehr benutzerfreundliche grafische Oberfläche für Git – ideal für Einsteiger und zur Visualisierung der Git-Historie.</p>
<h4>2.3.1 Repository in IntelliJ einrichten</h4>
<ol>
<li>VCS-Integration aktivieren:<br />Öffne dein Projekt in IntelliJ IDEA und gehe zu VCS &gt; Enable Version Control Integration. Wähle „Git“ aus.</li>
<li>Erstes Commit:<br />Öffne das Commit Fenster (über VCS &gt; Commit oder durch Drücken von Ctrl+K). IntelliJ zeigt dir alle geänderten Dateien an. Wähle diese aus, füge sie zur Staging Area hinzu und schreibe eine Commit-Nachricht. Anschließend kannst du committen und sofort pushen.</li>
<li>Branch-Verwaltung:<br />Über das Git-Widget in der rechten unteren Ecke kannst du Branches erstellen, wechseln und mergen. Rechtsklicke auf einen Branch, um Optionen wie Merge oder Rebase auszuwählen.</li>
<li>Remote Repositories nutzen:<br />Gehe zu VCS &gt; Git &gt; Remotes und füge den Remote-Repository-Link (z. B. von GitLab) hinzu. Mit den Optionen Push und Pull in der IDE kannst du die Änderungen synchronisieren.</li>
</ol>
<h4>2.3.2 Visuelle Darstellung</h4>
<p>IntelliJ IDEA bietet außerdem visuelle Git-Graphen, die die Commit-Historie und das Branching übersichtlich darstellen. Diese Diagramme helfen, den Entwicklungsfluss nachvollziehbar zu machen und Zusammenführungen (Merge) visuell zu überprüfen.</p>
<h3>2.4 Kollaborative Git-Arbeit: Pull Requests und Merge-Konflikte</h3>
<p>In Teamprojekten wird häufig mit Pull Requests (PR) gearbeitet, um Code-Reviews und die Integration von Feature-Branches in den Hauptbranch zu erleichtern.</p>
<ul>
<li>Pull Request erstellen:<br />Nachdem ein Feature-Branch in das Remote-Repository gepusht wurde, kann über die Weboberfläche (z. B. auf GitLab) ein PR erstellt werden. Im PR werden die Änderungen zusammengefasst, kommentiert und von anderen Teammitgliedern überprüft, bevor der Merge durchgeführt wird.</li>
<li>Merge-Konflikte:<br />Bei paralleler Bearbeitung können Merge-Konflikte auftreten. In diesem Fall zeigt Git an, welche Dateien betroffen sind. Entwickler beheben Konflikte manuell, indem sie die fehlerhaften Abschnitte editieren und den Konfliktbereich anschließend wieder „stagen“ und committen.</li>
</ul>
<h2>3. Dokumentation – Ein Fundament für Teamprojekte</h2>
<p>In interdisziplinären Projekten, wie sie im Studiengang Medieningenieur üblich sind, erweist sich eine lückenlose Dokumentation als unabdingbar. Sie dient nicht nur dazu, den Code verständlich und wartbar zu halten, sondern erhöht auch den sogenannten Truck-Factor (auch Bus-Factor genannt) – also die Sicherheit, dass kritisches Wissen nicht nur in den Köpfen einzelner Personen liegt. In diesem Abschnitt befassen wir uns mit zwei wesentlichen Dokumentationsmethoden:</p>
<ul>
<li>Klassendiagramme (UML)</li>
<li>Javadoc-Dokumentation</li>
</ul>
<p>Beide Instrumente tragen dazu bei, dass Aufgaben, Verantwortlichkeiten und Zusammenhänge in deinem Softwareprojekt transparent und nachvollziehbar dargestellt sind.</p>
<h3>3.1. UML-Klassendiagramme erstellen</h3>
<h4>3.1.1 Ziel und Nutzen von Klassendiagrammen</h4>
<p>Ein UML-Klassendiagramm visualisiert die statische Struktur eines Systems. Es zeigt, welche Klassen (als Baupläne von Objekten) im System existieren, welche Attribute und Methoden sie besitzen und wie sie zueinander in Beziehung stehen (wie etwa Vererbung, Assoziation oder Aggregation). Für Studierende, die bereits in den vorherigen Kapiteln Themen wie Klassen, Objekte und Vererbung kennengelernt haben, bietet das Klassendiagramm eine visuelle Zusammenfassung dieser Konzepte.</p>
<h4>3.1.2 Grundlegende Elemente eines Klassendiagramms</h4>
<p>Ein typisches UML-Klassendiagramm besteht aus drei Hauptbereichen in jeder Klassenbox:</p>
<ul>
<li>Oberer Bereich – Klassenname:
<ul>
<li>Enthält den Namen der Klasse (als Substantiv, z. B. Student, Auto oder Mediaplayer).</li>
</ul>
</li>
<li>Mittlerer Bereich – Attribute:
<ul>
<li>Listet die Eigenschaften der Klasse auf, wie Variablen oder Datenfelder.</li>
<li>Jedes Attribut wird oft mit einem Sichtbarkeitsmodifikator versehen:
<ul>
<li>+ für public</li>
<li>- für private</li>
<li># für protected</li>
</ul>
</li>
<li>Beispiel: -name: String, -alter: int</li>
</ul>
</li>
<li>Unterer Bereich – Methoden (Operationen):<br />
<ul>
<li>Zeigt das Verhalten der Klasse, d. h. die Aktionen, die Objekte dieser Klasse ausführen können.</li>
<li>Auch hier werden Sichtbarkeitsmodifikatoren verwendet, ebenso wie Parameterangaben und Rückgabetypen.</li>
<li>Beispiel: +getName(): String, +setAlter(int): void</li>
</ul>
</li>
</ul>
<h4>3.1.3 Beziehungen und Notationen</h4>
<p>Neben den inneren Elementen definieren Klassendiagramme auch die Beziehungen zwischen den Klassen. Zu den gängigen Beziehungstypen zählen:</p>
<ul>
<li>Assoziation:
<ul>
<li>Eine einfache Verbindung zwischen zwei Klassen, z. B. kann ein Student an mehreren Kursen teilnehmen.</li>
</ul>
</li>
<li>Vererbung (Generalization):
<ul>
<li>Zeigt an, dass eine Unterklasse von einer Oberklasse erbt (typisch dargestellt durch einen Pfeil, der von der Unterklasse zur Oberklasse zeigt).</li>
</ul>
</li>
<li>Aggregation und Komposition:
<ul>
<li>Aggregation steht für eine "hat-ein"-Beziehung, bei der die Teilobjekte auch unabhängig existieren können.</li>
<li>Komposition hingegen drückt eine starke Bindung aus, bei der das Teil ohne das Ganze nicht existieren kann.</li>
</ul>
</li>
<li>Abhängigkeiten (Dependencies):
<ul>
<li>Temporäre Beziehungen, die z. B. beim Aufrufen von Methoden entstehen können.</li>
</ul>
</li>
</ul>
<h4>3.1.4 Praktische Anleitung zum Erstellen eines Klassendiagramms</h4>
<ol>
<li>Systemüberblick verschaffen:
<ul>
<li>Bestimme den Zweck des Systems (z. B. ein Mediaplayer) und identifiziere die zentralen Klassen (z. B. Playlist, Song, MediaLibrary).</li>
</ul>
</li>
<li>Klassen und ihre Eigenschaften definieren:
<ul>
<li>Notiere, welche Attribute und Methoden jede Klasse enthalten soll.</li>
<li>Überlege, welchen Datentyp du für jedes Attribut benötigst (z. B. String, int, boolean).</li>
</ul>
</li>
<li>Beziehungen festlegen:
<ul>
<li>Bestimme, wie die Klassen miteinander verknüpft sind (z. B. erbt Mediaplayer von einer allgemeinen Klasse Device? Gibt es Assoziationen zwischen Playlist und Song?).</li>
</ul>
</li>
<li>Diagramm erstellen:
<ul>
<li>Nutze ein UML-Tool wie Lucidchart, draw.io oder PlantUML.</li>
<li>Ziehe Kästen für jede Klasse auf die Zeichenfläche, trage den Klassennamen, die Attribute und Methoden ein und verbinde die Klassen mit entsprechenden Linien (Pfeile für Vererbung, Linien mit Rauten für Aggregation/Komposition usw.).</li>
</ul>
</li>
<li>Beachte die Regeln:
<ul>
<li>Halte das Diagramm übersichtlich und vermeide Überladung mit unwichtigen Details.</li>
<li>Verwende konsistente Namenskonventionen (Klassennamen als Substantive, Methoden als Verben).</li>
<li>Die Sichtbarkeitsmodifikatoren sollten einheitlich und sinnvoll eingesetzt werden.</li>
<li>Prüfe, ob alle Beziehungen korrekt dargestellt und verständlich sind.</li>
</ul>
</li>
</ol>
<h4>3.1.5 Beispiel</h4>
<p>Ein einfaches Klassendiagramm für einen Mediaplayer könnte so aussehen:</p>
<p> <br />text</p>
<div class="pre-code">
<div>
<pre><code>+-----------------------+
|      MediaPlayer      |
+-----------------------+
| - volume: int         |
| - isPlaying: boolean  |
+-----------------------+
| + play(): void        |
| + pause(): void       |
| + stop(): void        |
+-----------------------+
            ▲
            │
+--------------------------+
|      AdvancedPlayer      |
+--------------------------+
| - equalizerSettings: int |
+--------------------------+
| + adjustEqualizer(): void|
+--------------------------+</code></pre>
</div>
</div>
<p>Hier sehen wir, dass AdvancedPlayer von MediaPlayer erbt, dass beide Klassen ihre Attribute und Methoden in getrennten Bereichen aufweisen und die Sichtbarkeit durch Symbole dargestellt wird.</p>
<h3>3.2. Javadoc-Dokumentation</h3>
<h4>3.2.1 Grundlagen und Zweck von Javadoc</h4>
<p>Javadoc ist das standardisierte Tool zur Erzeugung von API-Dokumentationen aus Java-Quellcode. Durch gut strukturierte Javadoc-Kommentare wird der Quellcode nicht nur für andere Entwickler verständlich, sondern auch für die langfristige Wartung des Codes dokumentiert. Dies ist besonders wichtig, wenn Teammitglieder wechseln oder bei der Einarbeitung neuer Mitglieder.</p>
<h4>2.2 Wie richtet man Javadoc ein?</h4>
<p><strong>Schritt 1: Kommentare im Code integrieren</strong></p>
<p>Für Klassen, Methoden und Felder fügst du Kommentare im folgenden Format hinzu:</p>
<div class="highlighted-code language-java">
<div>
<pre><code>/**
* Diese Methode berechnet die Summe von zwei Ganzzahlen.
*
* @param a Die erste Zahl.
* @param b Die zweite Zahl.
* @return Die Summe von a und b.
*/
public int add(int a, int b) {
return a + b;
}</code></pre>
</div>
</div>
<p>Achte darauf, beginnend mit /** und endend mit */ zu arbeiten. Verwende Tags wie @param, @return, und @throws, um Parameter, Rückgabewerte und potentielle Exceptions zu dokumentieren.</p>
<p><strong>Schritt 2: Javadoc über die Kommandozeile generieren</strong></p>
<p>Wechsle in das Verzeichnis, in dem sich dein Quellcode befindet. Führe folgenden Befehl aus, um die Dokumentation zu erstellen:</p>
<div class="highlighted-code code-style-2 language-markup">
<div>
<pre><code>javadoc -d doc -sourcepath src -subpackages com.meineprojekt</code></pre>
</div>
</div>
<ul>
<li>-d doc gibt an, dass die HTML-Dateien im Ordner „doc“ erstellt werden sollen.</li>
<li>-sourcepath src zeigt den Pfad zu deinem Quellcode.</li>
<li>-subpackages com.meineprojekt sorgt dafür, dass alle Unterpakete des angegebenen Pakets dokumentiert werden.</li>
</ul>
<p><strong>Schritt 3: Javadoc in der IDE generieren (IntelliJ IDEA)</strong></p>
<ul>
<li>Öffne dein Projekt in IntelliJ IDEA.</li>
<li>Gehe zu Tools &gt; Generate JavaDoc….</li>
<li>Wähle die zu dokumentierenden Module und lege den Zielordner für die HTML-Dokumentation fest.</li>
<li>Du kannst hier auch erweiterte Optionen anpassen (z. B. Sichtbarkeitsstufen), um festzulegen, welche Klassen und Methoden dokumentiert werden sollen.</li>
</ul>
<h4>3.2.3 Praktische Hinweise und Tipps</h4>
<ul>
<li>Regelmäßige Aktualisierung: Füge Javadoc-Kommentare von Beginn an in deinen Code ein und aktualisiere sie bei Änderungen, um eine stets aktuelle Dokumentation zu gewährleisten.</li>
<li>Vollständigkeit: Jede öffentliche und geschützte Methode sollte kommentiert sein. Dies unterstützt den Wissensaustausch und ist für die spätere Nutzung und Erweiterung unerlässlich.</li>
<li>Überprüfe die generierte Dokumentation: Oftmals können Tippfehler oder unvollständige Parameterangaben die automatische Dokumentation stören. Schaue dir im Anschluss immer die HTML-Dokumentation an, um Fehler zu erkennen und zu beheben.</li>
</ul>
<h3>3.4 Folgen mangelnder Dokumentation</h3>
<p>Fehlende oder unzureichende Dokumentation führt oft zu folgenden Problemen:</p>
<ul>
<li><strong>Wissensmonopol</strong>: Nur eine Person kennt die interne Struktur, was das Risiko eines niedrigen Truck-Factors erhöht.</li>
<li><strong>Erhöhter Einarbeitungsaufwand</strong>: Neue Teammitglieder müssen viel Zeit investieren, um sich in das Codebase einzuarbeiten.</li>
<li><strong>Fehleranfälligkeit</strong>: Fehlende Erklärungen zu Designentscheidungen können dazu führen, dass Änderungen fehlerhaft oder inkonsistent vorgenommen werden.<br /><br /></li>
</ul>
<h2>4. Verbindung von Versionskontrolle und Dokumentation in Teamprojekten</h2>
<p>Die Kombination aus präziser Versionskontrolle und umfassender Dokumentation ist der Schlüssel zum Erfolg in großen, interdisziplinären Projekten. Während Git dafür sorgt, dass alle Änderungen nachvollziehbar und umkehrbar sind, dokumentiert UML und Javadoc den Inhalt und die Architektur des Projekts. Gemeinsam vermeiden sie das Risiko, unschätzbares Wissen in den Köpfen weniger Teammitglieder zu konzentrieren, und schaffen Transparenz für alle Beteiligten.</p>
<p>─────────────────────────────────────────────</p>
<h1>Übungen</h1>
<h2>Aufgaben</h2>
<ul>
<li>Aufgabe 1: Git-Repository einrichten und bearbeiten:
<ul>
<li>Erstelle in IntelliJ IDEA ein neues Projekt und initialisiere ein Git-Repository (sowohl über die Kommandozeile als auch über die GUI).</li>
<li>Führe mehrere Commits durch, indem du Änderungen an Dateien vornimmst, sie mit git add zum Staging hinzufügst und anschließend git commit ausführst.</li>
<li>Erstelle einen neuen Branch, bearbeite darin eine Datei, löse einen einfachen Merge-Konflikt und merge den Branch in main.</li>
<li>Füge ein Remote-Repository (z. B. in GitLab) hinzu, pushe deine Commits und erzeuge einen Pull Request, den du anschließend zusammenführst.</li>
</ul>
</li>
<li>Aufgabe 2: Dokumentation erstellen:
<ul>
<li>Erstelle ein UML-Klassendiagramm für ein einfaches Mediaplayer-System mit Klassen wie Playlist, Song und MediaLibrary.</li>
<li>Ergänze den vorhandenen Java-Code mit ausführlichen Javadoc-Kommentaren und generiere die HTML-Dokumentation.</li>
<li>Diskutiere in einem kurzen Bericht, welche Konsequenzen fehlender Dokumentation für den Truck-Factor haben kann und welchen Einfluss dies auf die Teamarbeit hat.</li>
</ul>
</li>
</ul>
<h2>Fragen</h2>
<ul>
<li>Erkläre den Ablauf von git init, git add, git commit und git push. Wie hängen diese Befehle zusammen?</li>
<li>Was bedeutet der Begriff „staging area“ in Git, und warum ist das Staging vor dem Commit wichtig?</li>
<li>Wie wird in Git ein Remote-Repository eingerichtet und welchen Namen hat es standardmäßig? Welche Befehle werden verwendet, um Änderungen mit einem Remote-Repository zu synchronisieren?</li>
<li>Beschreibe, welche Vorteile UML-Diagramme und Javadoc-Dokumentation für die Zusammenarbeit in einem interdisziplinären Team bieten.</li>
<li>Wie können Pull Requests zu einer höheren Codequalität beitragen und welche Rolle spielen sie im Zusammenführungsprozess von Branches?</li>
</ul>
<h1>Zusammenfassung</h1>
<ul>
<li>Git-Grundlagen:
<ul>
<li>Mit git init, git add, git commit und git push werden Änderungen verwaltet und dokumentiert.</li>
<li>Branches ermöglichen die parallele Bearbeitung, während Merge-Befehle diese Änderungen in den Hauptbranch integrieren.</li>
<li>Remote-Repositorys (in der Regel unter dem Namen „origin“) sorgen für die Zusammenarbeit über zentrale Server (z. B. GitLab).</li>
</ul>
</li>
<li>Git in IntelliJ IDEA:
<ul>
<li>Die IDE bietet visuelle Werkzeuge zur Git-Integration, inklusive Menüoptionen zum Committen, Branch-Wechseln und Mergen.</li>
<li>Es werden beide Arbeitsweisen gezeigt: Kommandozeile und GUI.</li>
</ul>
</li>
<li>Dokumentation:
<ul>
<li>UML-Diagramme visualisieren die Architektur, während Javadoc den Quellcode durch Kommentare dokumentiert.</li>
<li> Klassendiagramme:
<ul>
<li>Elemente: Klassenname, Attribute, Methoden</li>
<li>Beziehungen: Vererbung, Assoziation, Aggregation, Komposition, Abhängigkeiten</li>
<li>Regeln: Klare Struktur, konsistente Notation (Sichtbarkeitsmodifikatoren), übersichtliche Anordnung, nur relevante Informationen darstellen</li>
</ul>
</li>
<li>Javadoc:
<ul>
<li>Einrichtung: Kommentare mit /** ... */ direkt im Code, Nutzung von Tags wie @param, @return und @throws</li>
<li>Generierung: Verwendung des javadoc-Befehls über die Kommandozeile (z. B. javadoc -d doc -sourcepath src -subpackages &lt;paketname&gt;) oder über die IDE (IntelliJ IDEA: Tools &gt; Generate JavaDoc…)</li>
<li>Ziel: Vollständige, strukturierte und stets gepflegte API-Dokumentation, die den Wissenstransfer im Team erleichtert</li>
</ul>
</li>
<li>Eine lückenlose Dokumentation erhöht den Truck-Factor und erleichtert die Einarbeitung und Zusammenarbeit.</li>
</ul>
</li>
<li>Kollaborative Entwicklung:
<ul>
<li>Praktiken wie Pull Requests und Pair Programming fördern den Wissensaustausch und die Codequalität.</li>
</ul>
</li>
</ul>
<p></p></div>
</div>
</div>
</article>
<div id="packageLicense" class="cc cc-by-sa">
<p><span>Lizenziert unter  </span> <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution Share Alike License 4.0</a></p>
</div>
</section>
</div>
<div id='bottomPagination'>
<nav class="pagination noprt">
<a href="design_patterns.html" class="prev"><span><span>&laquo; </span>Vorheriges</span></a>
</nav>
</div>
</div>
<p id="made-with-eXe"><a href="https://exelearning.net/" target="_blank" rel="noopener"><span>Made with eXeLearning<span> (Neues Fenster)</span></span></a></p><script type="text/javascript" src="_style_js.js"></script></body></html>